---
runme:
  id: fleetfolio-eaa-pentest-lite
  name: "Fleetfolio EAA – Pentest Lite (Authorized)"
  version: "2.0.0"
  maintainer: "Fleetfolio Team"
  description: "Lightweight, authorized, container-run external asset assessment with structured artifacts."
---

# Fleetfolio EAA – Pentest Lite (Authorized)

This Runme runbook performs an **authorized, lightweight external asset assessment** inside an OWASP Nightingale container
(default base: `rajanagori/nightingale:latest`). It orchestrates a chain of reconnaissance and validation tools to
discover domains, resolve DNS, probe for web services, scan ports, fingerprint technologies, check TLS certificates, and run
targeted vulnerability checks. All artifacts are stored under `/var/fleetfolio/eaa/<tool>/…` in structured formats such as
JSON, JSONL, XML, or plain text.

The runbook is meant to be **safe, idempotent, and scope-aware**, honoring exclusions and customer authorization.

## Manual Installation of Kali Linux in VirtualBox

This guide will help you manually install **Kali Linux** in **VirtualBox** on your host machine.

### Prerequisites

- **VirtualBox**: [Download VirtualBox](https://www.virtualbox.org/wiki/Downloads)
- **Kali Linux Virtual Machine**: [Download Kali Linux VM](https://www.kali.org/get-kali/#kali-platforms) (VirtualBox, 3.3 GB, `.7z` file)
- **WinRAR** or **7-Zip** for extraction: [Download WinRAR](https://www.win-rar.com/download.html?&L=0) (recommended)

#### Steps

1. **Download Kali Linux**

   - Select **Virtual Machine** and then **VirtualBox (3.3 GB)**.
   - The file will be in `.7z` format.

2. **Download and install VirtualBox**

   - Open [VirtualBox Downloads](https://www.virtualbox.org/wiki/Downloads) and install it on your host machine.

3. **Extract Kali Linux VM**

   - Use **WinRAR** or **7-Zip** to extract the `.7z` file to your **Downloads** folder.
   - Double-click the `.vdi` file to automatically import Kali Linux into VirtualBox.

4. **Configure the Virtual Machine**

   - Set **Base Memory** to `4096 MB` (recommended).
   - Set **Processor Cores** to `2–3` (recommended).
   - Start the virtual machine.

5. **Login**

- Default credentials:

```text { ignore=true }
Username: kali
Password: kali
```

6. **Switch to Root User**

- Open the terminal and type:

```bash { ignore=true }
sudo su
```

- This will give you root privileges (most privileged user).

7. **Update the System**

- In the terminal, run:

```bash { ignore=true }
sudo apt update && sudo apt upgrade -y && sudo apt full-upgrade -y
```

- This will ensure your system is fully updated and prevent errors when installing tools.

**Note:** Always use updated VirtualBox and Kali Linux versions to avoid compatibility issues.

## Environment Variables

- `FLEETFOLIO_EAA_HOME` (default: `.fleetfolio/eaa` in current directory)
- `FLEETFOLIO_EAA_DOMAINS` – comma- or space-separated domains
- `FLEETFOLIO_EAA_IP_RANGES` – comma- or space-separated IPs/CIDRs
- `FLEETFOLIO_EAA_KEY_URLS` – comma- or space-separated URLs/APIs
- `FLEETFOLIO_EAA_EXCLUDES` – comma- or space-separated exclusions
- `FLEETFOLIO_EAA_RATE_LIMIT` (default: 200)
- `FLEETFOLIO_EAA_CONCURRENCY` (default: 50)
- `FLEETFOLIO_EAA_NAABU_PORTS` (default: top-100)
- `FLEETFOLIO_EAA_NUCLEI_TEMPLATES` (default: cves,default)

# Initialization and Logging

The runbook begins by creating a working directory for session data, evidence, and logs. It snapshots all Fleetfolio-related
environment variables so that the test configuration is preserved for auditability. The master log file is written to
`$FLEETFOLIO_EAA_HOME/runbook.log`.

```bash { name=init }
: "${FLEETFOLIO_EAA_HOME:=$(pwd)/.fleetfolio/eaa}"
mkdir -p "$FLEETFOLIO_EAA_HOME/session"
LOG="$FLEETFOLIO_EAA_HOME/runbook.log"

(env | grep ^FLEETFOLIO_EAA_ || true) > "$FLEETFOLIO_EAA_HOME/arguments.env"
echo "[init] Snapshot written to $FLEETFOLIO_EAA_HOME/arguments.env" | tee -a "$LOG"
```

Artifacts: `$FLEETFOLIO_EAA_HOME/arguments.env` (environment variables in `key=value` format) and the master runbook log
at `$FLEETFOLIO_EAA_HOME/runbook.log`.

# Scope Normalization

Environment variables are convenient but not ideal for tool chaining. Here we normalize them into newline-delimited files so
each tool can consume scope easily.

```bash { name=normalize_scope }
mkdir -p "$FLEETFOLIO_EAA_HOME/session"

echo "${FLEETFOLIO_EAA_DOMAINS:-}"   | tr ', ' '\n' | sed '/^$/d' > "$FLEETFOLIO_EAA_HOME/session/domains.txt"
echo "${FLEETFOLIO_EAA_IP_RANGES:-}" | tr ', ' '\n' | sed '/^$/d' > "$FLEETFOLIO_EAA_HOME/session/ip_ranges.txt"
echo "${FLEETFOLIO_EAA_KEY_URLS:-}"  | tr ', ' '\n' | sed '/^$/d' > "$FLEETFOLIO_EAA_HOME/session/key_urls.txt"
echo "${FLEETFOLIO_EAA_EXCLUDES:-}"  | tr ', ' '\n' | sed '/^$/d' > "$FLEETFOLIO_EAA_HOME/session/excludes.txt"
```

Artifacts: text files under `$FLEETFOLIO_EAA_HOME/session/` for domains, IP ranges, key URLs, and excludes.

# Subfinder – Discovering Subdomains

[Subfinder](https://github.com/projectdiscovery/subfinder) passively collects subdomains for a given set of domains. Its
purpose in this chain is to broaden the scope of assets by identifying potentially forgotten or shadow subdomains. This step
feeds DNS resolution and subsequent probing.

```bash { name=subfinder }
OUT="/var/fleetfolio/eaa/subfinder/subfinder.jsonl"
if [ -s "$FLEETFOLIO_EAA_HOME/session/domains.txt" ]; then
  subfinder -dL "$FLEETFOLIO_EAA_HOME/session/domains.txt" -oJ -o "$OUT"         -rate "${FLEETFOLIO_EAA_RATE_LIMIT:-200}" -silent || true
fi
```
Artifacts: JSONL file at `/var/fleetfolio/eaa/subfinder/subfinder.jsonl`, one JSON record per subdomain discovered.

# dnsx – Resolving Hosts

[dnsx](https://github.com/projectdiscovery/dnsx) resolves hostnames into their DNS records. After discovering candidate
subdomains, this step verifies which are actually live and resolvable, ensuring later stages only work on valid targets.

```bash { name=dnsx }
OUT="/var/fleetfolio/eaa/dnsx/dnsx.jsonl"
jq -r 'select(.host!=null) | .host' /var/fleetfolio/eaa/subfinder/subfinder.jsonl       | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"       | dnsx -json -silent -o "$OUT" || true
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/dnsx/dnsx.jsonl` containing resolved IPs, CNAMEs, and other DNS data.

# httpx – Probing Web Services

[httpx](https://github.com/projectdiscovery/httpx) takes hostnames or URLs and determines if web services are running. This
step validates web endpoints, collects basic response metadata, and provides input for fingerprinting and vulnerability
scanning.

```bash { name=httpx }
OUT="/var/fleetfolio/eaa/httpx/httpx.jsonl"
jq -r .host /var/fleetfolio/eaa/dnsx/dnsx.jsonl       | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"       > targets.txt || true
cat "$FLEETFOLIO_EAA_HOME/session/key_urls.txt" >> targets.txt || true
httpx -l targets.txt -json -silent       -rate "${FLEETFOLIO_EAA_RATE_LIMIT:-200}" -threads "${FLEETFOLIO_EAA_CONCURRENCY:-50}"       -o "$OUT"
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/httpx/httpx.jsonl` with fields like URL, status code, title, webserver header.

# WhatWeb – Fingerprinting Technologies

[WhatWeb](https://github.com/urbanadventurer/WhatWeb) fingerprints the technologies used on web servers. By running this
after `httpx`, we enrich the inventory with details such as CMS platforms, frameworks, and versions.

```bash { name=whatweb }
for url in $(jq -r .url /var/fleetfolio/eaa/httpx/httpx.jsonl                  | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"); do
  safe=$(echo "$url" | sed 's#[/:]#_#g')
  whatweb --log-json="/var/fleetfolio/eaa/whatweb/$safe.json" "$url" || true
done
```

Artifacts: per-target JSON files under `/var/fleetfolio/eaa/whatweb/` with detected technologies.

# Naabu – Scanning Open Ports

[Naabu](https://github.com/projectdiscovery/naabu) is a fast TCP port scanner. After DNS resolution, it quickly checks which
ports are open across the in-scope hosts and IP ranges. This sets up service enumeration by Nmap.

```bash { name=naabu }
jq -r .host /var/fleetfolio/eaa/dnsx/dnsx.jsonl       | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"       > naabu_hosts.txt || true
naabu -list naabu_hosts.txt -json -silent       -top-ports "${FLEETFOLIO_EAA_NAABU_PORTS#top-}"       -rate "${FLEETFOLIO_EAA_RATE_LIMIT:-200}" -c "${FLEETFOLIO_EAA_CONCURRENCY:-50}"       -o /var/fleetfolio/eaa/naabu/naabu.jsonl
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/naabu/naabu.jsonl` with IP and port fields.

# Nmap – Service Enumeration

[Nmap](https://nmap.org/) probes the open ports identified by Naabu and attempts to detect service versions. This helps
validate what services are actually exposed and whether outdated or risky protocols are in use.

```bash { name=nmap }
jq -r '"\(.ip):\(.port)"' /var/fleetfolio/eaa/naabu/naabu.jsonl > nmap_targets.txt
nmap -sV -Pn -n -oX /var/fleetfolio/eaa/nmap/services.xml -iL nmap_targets.txt || true
xq < /var/fleetfolio/eaa/nmap/services.xml > /var/fleetfolio/eaa/nmap/services.json || true
```

Artifacts: XML and JSON representations of Nmap results at `/var/fleetfolio/eaa/nmap/`.

# OpenSSL – Inspecting TLS Certificates

[OpenSSL](https://www.openssl.org/) is used to connect to HTTPS endpoints and retrieve their certificate chains. This provides
visibility into certificate expiry, issuer trust, SANs, and potential weak algorithms.

```bash { name=openssl }
for host in $(jq -r .host /var/fleetfolio/eaa/httpx/httpx.jsonl                   | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"); do
  echo | openssl s_client -servername $host -connect $host:443 -showcerts 2>/dev/null         > "/var/fleetfolio/eaa/tls/$host.txt" || true
done
```

Artifacts: plain text certificate details in `/var/fleetfolio/eaa/tls/*.txt`.

# Nuclei – Template-Based Vulnerability Scanning

[Nuclei](https://github.com/projectdiscovery/nuclei) runs a library of templates to check for common vulnerabilities and
misconfigurations. In this chain, it is run with conservative templates (CVEs and defaults) to flag potentially high-value
findings without overwhelming the customer with noise.

```bash { name=nuclei }
jq -r .url /var/fleetfolio/eaa/httpx/httpx.jsonl       | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"       > nuclei_targets.txt || true
nuclei -l nuclei_targets.txt -jsonl -silent       -rate-limit "${FLEETFOLIO_EAA_RATE_LIMIT:-200}" -c "${FLEETFOLIO_EAA_CONCURRENCY:-50}"       -tags "${FLEETFOLIO_EAA_NUCLEI_TEMPLATES:-cves,default}"       -o /var/fleetfolio/eaa/nuclei/nuclei.jsonl
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/nuclei/nuclei.jsonl` with one result per finding.

# Katana – Crawling for Endpoints

[Katana](https://github.com/projectdiscovery/katana) is a web crawler that discovers additional endpoints within known web
applications. While optional, including it here provides extra surface area for vulnerability scanning.

```bash { name=katana }
if command -v katana >/dev/null; then
  jq -r .url /var/fleetfolio/eaa/httpx/httpx.jsonl         | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"         > katana_targets.txt || true
  katana -list katana_targets.txt -silent -o /var/fleetfolio/eaa/katana/katana.jsonl || true
fi
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/katana/katana.jsonl` listing discovered endpoints.

# tlsx – TLS Metadata Extraction

[tlsx](https://github.com/projectdiscovery/tlsx) extracts structured TLS metadata without full OpenSSL transcripts. It is
useful as a lightweight, JSON-friendly complement to the OpenSSL raw dumps.

```bash { name=tlsx }
if command -v tlsx >/dev/null; then
  jq -r .host /var/fleetfolio/eaa/httpx/httpx.jsonl         | grep -v -F -f "$FLEETFOLIO_EAA_HOME/session/excludes.txt"         > tlsx_targets.txt || true
  tlsx -list tlsx_targets.txt -silent -o /var/fleetfolio/eaa/tls/tlsx.jsonl || true
fi
```

Artifacts: JSONL file at `/var/fleetfolio/eaa/tls/tlsx.jsonl` with structured TLS details.

# Summary

Finally, we summarize counts of findings and provide hints for what to review next.

```bash { name=summary }
echo "=== Summary of Findings ==="
for f in subfinder dnsx httpx naabu nuclei katana; do
  path="/var/fleetfolio/eaa/$f/$f.jsonl"
  if [ -s "$path" ]; then
    echo "$f: $(wc -l < $path) lines"
  fi
done
echo "WhatWeb: $(ls -1 /var/fleetfolio/eaa/whatweb/*.json 2>/dev/null | wc -l) files"
echo "Nmap: $(ls -1 /var/fleetfolio/eaa/nmap/* 2>/dev/null | wc -l) files"
echo "TLS: $(ls -1 /var/fleetfolio/eaa/tls/* 2>/dev/null | wc -l) files"

echo
echo "Next steps:"
echo " - Review nuclei results by severity and template."
echo " - Inspect WhatWeb outputs for outdated technologies."
echo " - Validate service exposure in nmap JSON output."
echo " - Audit TLS metadata in both OpenSSL text and tlsx JSONL."
echo " - Cross-check discovered assets against official inventories."
```

Artifacts: summary counts printed to console; references to JSONL, JSON, XML, and plaintext outputs.

# Analyst’s Guide to Interpreting Artifacts

This appendix provides practical advice for reviewing the artifacts generated by each tool. It is meant for analysts who may
not be familiar with the nuances of every tool but need to make sense of the outputs.

## Subfinder (`subfinder.jsonl`)

Each line is a JSON object with a `host` field and the `source` where it was discovered. Analysts should look for:

- Subdomains that are unexpected or unmanaged.
- Entries that do not resolve later in dnsx, which may indicate legacy or abandoned records.

## dnsx (`dnsx.jsonl`)

DNS resolution results will include IPs (A/AAAA records), CNAMEs, and other metadata. Analysts should:

- Verify that IPs map to owned infrastructure.
- Flag any pointing to cloud or third-party networks that might be unmanaged.

## httpx (`httpx.jsonl`)

Contains metadata for live web services: status codes, titles, server headers. Analysts should:

- Look for sensitive endpoints (e.g., admin panels, login portals).
- Pay attention to unusual server headers or technologies that don’t align with policy.

## WhatWeb (`whatweb/*.json`)

Per-target JSON files list detected plugins/technologies. Analysts should:

- Identify outdated CMS or frameworks (e.g., old WordPress, Joomla).
- Cross-check detected versions against known vulnerabilities.

## Naabu (`naabu.jsonl`)

JSON lines listing IPs and open ports. Analysts should:

- Spot unexpected open ports (e.g., databases, RDP, SSH exposed externally).
- Focus on high-risk services like SMB, Telnet, or legacy protocols.

## Nmap (`services.xml`, `services.json`)

Provides enriched service banners and versions. Analysts should:

- Confirm the accuracy of Naabu findings.
- Evaluate service versions for end-of-life software.

## OpenSSL (`tls/*.txt`)

Raw transcripts of TLS handshakes and certificate chains. Analysts should:

- Check expiry dates, SAN entries, and certificate issuers.
- Flag self-signed or weakly signed certificates.

## Nuclei (`nuclei.jsonl`)

Each JSON line represents a finding matched against a template. Analysts should:

- Sort by severity to prioritize triage.
- Validate important findings manually before reporting.

## Katana (`katana.jsonl`)

Lists discovered web endpoints through crawling. Analysts should:

- Look for API endpoints, hidden admin paths, or sensitive resources.
- Cross-reference endpoints against vulnerability scan coverage.

## tlsx (`tlsx.jsonl`)

Structured TLS metadata such as cipher suites and certificate details. Analysts should:

- Use this to complement OpenSSL outputs with machine-friendly JSON data.
- Review for weak ciphers or deprecated protocol versions.

---

This guide should be used alongside the summary step to quickly assess which artifacts need deeper analysis.
