---
doc-classify:
  - select: heading[depth="1"]
    role: project
  - select: heading[depth="2"]
    role: tools
  - select: heading[depth="3"]
    role: explanations

spry:
  id: fleetfolio-eaa-pentest-lite
  name: "Fleetfolio EAA – Pentest Lite (Authorized)"
  version: "0.1.11"
  maintainer: "Fleetfolio Team"
  description: "Lightweight, authorized, container-run external asset assessment with structured artifacts."
---

This spry runbook performs an **authorized, lightweight external asset assessment** inside an Kali linux container
(default base: `kalilinux/kali-last-release`). It orchestrates a chain of reconnaissance and validation tools to
discover domains, resolve DNS, probe for web services, scan ports, fingerprint technologies, check TLS certificates, and run
targeted vulnerability checks. All artifacts are stored under `/opt/eaa/sessions/$timestamps/<tool>/…` in structured formats such as
JSON, JSONL, XML, or plain text.

The runbook is meant to be **safe, idempotent, and scope-aware**, honoring exclusions and customer authorization.

All the packages come from `Debian`. When they don’t come from Debian, we use `Homebrew`. If not available in Homebrew, we use `eget`. If none of these work, we install it directly using the runtime installation instructions.

# Roadmap

- [ ] Introduce [Masscan](https://www.kali.org/tools/masscan/) for High-speed Internet-scale port scanning with banner grabbing
- [ ] Introduce [AutoRecon](https://github.com/Tib3rius/AutoRecon) for Comprehensive automated reconnaissance with 35+ parameters
- [ ] Introduce [Fierce](https://github.com/mschwager/fierce) for DNS reconnaissance and zone transfer testing

# Manual Installation of Kali Linux in VirtualBox

This guide will help you manually install **Kali Linux** in **VirtualBox** on your host machine.

#### Prerequisites

- **VirtualBox**: [Download VirtualBox](https://www.virtualbox.org/wiki/Downloads)
- If you are using Windows as the host machine, you may encounter an error while downloading or installing VirtualBox due to missing Visual C++ dependencies. To resolve this, download the package from [Visual C++ Redistributable Runtimes All-in-One](https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one)
   and run the `install_all.bat` file.
- **Kali Linux Virtual Machine**: [Download Kali Linux VM](https://www.kali.org/get-kali/#kali-platforms) (VirtualBox, 3.3 GB, `.7z` file)
- **WinRAR** or **7-Zip** for extraction: [Download WinRAR](https://www.win-rar.com/download.html?&L=0) (recommended)

#### Steps

1. **Download Kali Linux**

   - Select **Virtual Machine** and then **VirtualBox (3.3 GB)**.
   - The file will be in `.7z` format.

2. **Download and install VirtualBox**

   - Open [VirtualBox Downloads](https://www.virtualbox.org/wiki/Downloads) and install it on your host machine.

3. **Extract Kali Linux VM**

   - Use **WinRAR** or **7-Zip** to extract the `.7z` file to your **Downloads** folder.
   - There will be two files: A `.vdi` file (orange icon) and one `.vbox file` (blue icon). Double-click on the `.vbox` file to automatically import the Kali Linux Machine into VirtualBox.

4. **Configure the Virtual Machine**

   - Set **Base Memory** to `4096 MB` (recommended).
   - Set **Processor Cores** to `2–3` (recommended).
   - Start the virtual machine.

5. **Login**

- Default credentials:

```bash 
Username: kali
Password: kali
```

6. **Switch to Root User**

- Open the terminal and type:

```bash 
sudo su
```

- This will give you root privileges (most privileged user).

7. **Update the System**

- In the terminal, run:

```bash 
sudo apt update && sudo apt upgrade -y && sudo apt full-upgrade -y
```

- This will ensure your system is fully updated and prevent errors when installing tools.

**Note:** Always use updated VirtualBox and Kali Linux versions to avoid compatibility issues.

#### Fixing Errors

If you encounter any errors while running the above system update commands, follow these steps:

```bash 
sudo sed -i 's|http://http.kali.org|https://http.kali.org|' /etc/apt/sources.list
```

Then run the following commands one by one:

```bash 
sudo apt-get clean && sudo apt-get update --fix-missing
```

Then run the system update command again:

```bash 
sudo apt update && sudo apt upgrade -y && sudo apt full-upgrade -y
```

---

#### Prerequisite Dependency

**Homebrew**

```bash 
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" && echo >> /home/kali/.zshrc && echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"' >> /home/kali/.zshrc && eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" && sudo apt-get install -y build-essential && brew install gcc
```

Note : Run this command inside a non-root user terminal. You will be prompted to enter the password, and then press Enter again to continue

**Go**

```bash 
sudo apt install golang-go -y
```
---

#### Install [Deno](https://github.com/denoland/deno)

Deno is a modern, secure runtime for JavaScript and TypeScript built on the V8 engine and written in Rust. It provides built-in support for TypeScript, uses ES modules, and emphasizes security by requiring explicit permissions for file, network, and environment access. Deno also includes a built-in dependency inspector, formatter, and test runner for streamlined development.

```bash 
brew install deno
```

#### Install [Surveilr](https://www.surveilr.com/)

Get the latest Resource Surveillance & Integration Engine (surveilr) for Critical Systems by following these steps to complete the installation:

```bash 
wget https://github.com/surveilr/packages/releases/download/3.31.0/surveilr_3.31.0_x86_64-unknown-linux-gnu.tar.gz && \
tar -xvf surveilr_3.31.0_x86_64-unknown-linux-gnu.tar.gz && \
mv surveilr /usr/local/bin
```
- Please try to download the latest version. You can find latest releases [here](https://github.com/opsfolio/releases.opsfolio.com/releases)

Homebrew-installed tools not accessible when switching to root user (Solution: Add Homebrew to root’s shell environment)

```bash 
sudo su && echo 'eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"' >> /root/.zshrc && eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
```
- Paste it again after switching to the root user.
---

#### Prerequisite API Keys/Tokens

**[WPScan](https://wpscan.com/)**

WPScan is a security scanning tool designed specifically for WordPress websites. It identifies common vulnerabilities and security issues using an extensive WordPress vulnerability database.

##### Steps
- Visit the [WPScan Registration Page](http://wpscan.com/register/).
- Fill out the registration form and verify your email address.
- Sign in to your WPScan account.
- Locate or generate your API key and add it to the `.env` file.

---

**[VirusTotal](https://www.virustotal.com/)**

VirusTotal is an online threat intelligence and malware analysis platform that scans files, URLs, domains, and IPs using multiple antivirus engines and security tools.

##### Steps
- Visit the [VirusTotal Login/Signup Page](https://www.virustotal.com/gui/join-us).
- Create a new account by providing the required details.
- Verify your email address to activate the account.
- Sign in to your VirusTotal dashboard.
- Copy your API key and add it to the `.env` file.

---

#### Tools Required and Their Installation Steps

#### Whatweb, Nmap, Openssl, wafw00f, sqlmap, WPScan, Amass, Nikto, DNSEnum, TheHarvester, SSLyze, smtp-user-enum are Pre-installed in kali linux

```bash 
sudo apt install -y subfinder dnsx httpx-toolkit naabu nuclei xq jq dirsearch testssl.sh paramspider commix && \
git clone https://github.com/s0md3v/Corsy.git && cd Corsy && pip3 install -r requirements.txt --break-system-packages
go install github.com/projectdiscovery/katana/cmd/katana@latest && sudo cp ~/go/bin/katana /bin/  && \
go install github.com/projectdiscovery/tlsx/cmd/tlsx@latest && sudo cp ~/go/bin/tlsx /bin/ && \
go install -v github.com/PentestPad/subzy@latest && sudo cp ~/go/bin/subzy /bin/ && \
go install -v github.com/projectdiscovery/pdtm/cmd/pdtm@latest && sudo cp ~/go/bin/pdtm /bin/ && \
go install github.com/intigriti/misconfig-mapper/cmd/misconfig-mapper@latest && sudo cp ~/go/bin/misconfig-mapper /bin/ && \
sudo apt install -y libpcap-dev && pdtm -install-all && sudo cp /home/kali/.pdtm/go/bin/* /bin && \
git clone https://github.com/r0oth3x49/ghauri.git && cd ghauri && sudo python3 setup.py install && \
pip install fierce --break-system-packages && \
wget https://github.com/cerberauth/vulnapi/releases/download/v0.8.9/vulnapi_0.8.9_linux_amd64.deb && \
dpkg -i vulnapi_0.8.9_linux_amd64.deb && \
git clone https://github.com/nemesida-waf/waf_bypass.git waf_bypass && cd waf_bypass && pip3 install -r requirements.txt --break-system-packages && \
brew install rustscan dalfox trivy safedep/tap/vet
```

#### Next Clone this repo

```bash 
git clone https://github.com/surveilr/www.surveilr.com.git && \
cd www.surveilr.com/lib/service/fleetfolio/eaa
```

- Then add the domains, URLs, IPs, etc. inside the .env file.
   Example

```bash 
sudo tee -a .env > /dev/null << 'EOF'

# Copy this file to ".env" and adjust values as needed.
# docker-compose will automatically read .env in the same folder.

# Scope configuration (space- or comma-separated)
OPSFOLIO_EAA_HOME=/opt/eaa/sessions
OPSFOLIO_EAA_TENANT_ID=NET1234
OPSFOLIO_EAA_TENANT_NAME=Netspective
OPSFOLIO_EAA_PURPOSE=Threat
OPSFOLIO_EAA_DESCRIPTION=Demo_Threat
OPSFOLIO_EAA_CONTEXT_JSON='{ "Sample": "Value" }'
OPSFOLIO_EAA_EXIT_EMAIL_ADDRESSES=example@nespective.com,example2@nespective.com,example3@gmal.com
OPSFOLIO_EAA_DOMAINS=netspective.com
OPSFOLIO_EAA_SUBDOMAINS=
OPSFOLIO_EAA_IP_RANGES=
OPSFOLIO_EAA_EXCLUDES=
OPSFOLIO_EAA_KEY_URLS=https://netspective.com/
OPSFOLIO_EAA_KEY_APIS=
OPSFOLIO_EAA_KEY_GIT_URLS=
OPSFOLIO_EAA_CORSY_PATH=/opt/eaa/Corsy
OPSFOLIO_EAA_WAF_BYPASS_PATH=/opt/eaa/waf-bypass
OPSFOLIO_EAA_WP_TOKEN=TOKEN
OPSFOLIO_EAA_VIRUSTOTAL_API_KEY=KEY
OPSFOLIO_EAA_RATE_LIMIT=200
OPSFOLIO_EAA_CONCURRENCY=50
OPSFOLIO_EAA_NAABU_PORTS=top-100
OPSFOLIO_EAA_NUCLEI_TEMPLATES=cves,default

EOF
```
#### Install [spry](https://sprymd.org/)

- Before installing spry, make sure that you have installed deno.

```bash 
brew install programmablemd/packages/spry
```
Make sure you have installed `brew` using the steps above and that it is also available for the `root user`, as mentioned earlier.

#### Run spry to Execute Fleetfolio Pentest Workflow EAA

1. To run the entire code:

```bash 
sudo spry rb run fleetfolio-eaa-pentest-lite.spry.md --verbose rich
```

2. To run single code at a time:

```bash 
sudo spry rb task <task_id> fleetfolio-eaa-pentest-lite.spry.md --verbose rich
```
- If a graph is mentioned in the markdown of any script, the above two commands will not work. You must also include the `--graph` flag, as shown below.

3. To run a specific cell:

```bash
sudo spry rb run fleetfolio-eaa-pentest-lite.spry.md --graph <name> --verbose rich
```

Note: Make sure you are given the task_id while declaring a snippet as shown in below. Visit this [docmentation](https://sprymd.org/docs)

---

#### Automated Method (Docker)

- First, download Docker. If Docker is already installed, you can skip this step. Ensure that Docker is running by checking `sudo systemctl status docker`. If it is not running, enable and start it with `sudo systemctl enable docker --now`.

```bash 
sudo apt update && sudo apt install docker.io -y && sudo systemctl enable docker --now
```

If you encounter any errors while running the above system update commands, follow these steps:

```bash 
sudo sed -i 's|http://http.kali.org|https://http.kali.org|' /etc/apt/sources.list && sudo apt-get clean && sudo apt-get update --fix-missing
```

- Then Clone this repo

```bash 
git clone https://github.com/surveilr/www.surveilr.com.git && \
cd www.surveilr.com/lib/service/fleetfolio/eaa
```

- Then add the domains, URLs, IPs, etc. inside the .env file.
   Example

```bash 
sudo tee -a .env > /dev/null << 'EOF'

# Copy this file to ".env" and adjust values as needed.
# docker-compose will automatically read .env in the same folder.

# Scope configuration (space- or comma-separated)
OPSFOLIO_EAA_HOME=/opt/eaa/sessions
OPSFOLIO_EAA_TENANT_ID=NET1234
OPSFOLIO_EAA_TENANT_NAME=Netspective
OPSFOLIO_EAA_PURPOSE=Threat
OPSFOLIO_EAA_DESCRIPTION=Demo_Threat
OPSFOLIO_EAA_CONTEXT_JSON='{ "Sample": "Value" }'
OPSFOLIO_EAA_EXIT_EMAIL_ADDRESSES=example@nespective.com,example2@nespective.com,example3@gmal.com
OPSFOLIO_EAA_DOMAINS=netspective.com
OPSFOLIO_EAA_SUBDOMAINS=
OPSFOLIO_EAA_IP_RANGES=
OPSFOLIO_EAA_EXCLUDES=
OPSFOLIO_EAA_KEY_URLS=https://netspective.com/
OPSFOLIO_EAA_KEY_APIS=
OPSFOLIO_EAA_KEY_GIT_URLS=
OPSFOLIO_EAA_CORSY_PATH=/opt/eaa/Corsy
OPSFOLIO_EAA_WAF_BYPASS_PATH=/opt/eaa/waf-bypass
OPSFOLIO_EAA_WP_TOKEN=TOKEN
OPSFOLIO_EAA_VIRUSTOTAL_API_KEY=KEY
OPSFOLIO_EAA_RATE_LIMIT=200
OPSFOLIO_EAA_CONCURRENCY=50
OPSFOLIO_EAA_NAABU_PORTS=top-100
OPSFOLIO_EAA_NUCLEI_TEMPLATES=cves,default

EOF
```

- Then follow these steps

```bash 
sudo docker build -t fleetfolio-eaa:latest . && \
sudo docker run --rm -it -v $(pwd)/results:/opt/eaa/sessions/ fleetfolio-eaa:latest
```

Note: After running the `docker run` command, a new directory called `results` will be created in the current path on your local machine. This directory will contain the generated results from the Docker container, based on the scope you provided.

#### Environment Variables

- `OPSFOLIO_EAA_HOME` – (default: `opt/eaa/sessions`)
- `OPSFOLIO_EAA_TENANT_ID` – tenant IDs, separated by commas or spaces
- `OPSFOLIO_EAA_TENANT_NAME` – tenant names, separated by commas or spaces
- `OPSFOLIO_EAA_PURPOSE`   –    required string
- `OPSFOLIO_EAA_DESCRIPTION` –   optional string
- `OPSFOLIO_EAA_CONTEXT_JSON`   –     optional JSON object
- `OPSFOLIO_EAA_EXIT_EMAIL_ADDRESS` – email address comma- or space-separated
- `OPSFOLIO_EAA_DOMAINS` – comma- or space-separated domains
- `OPSFOLIO_EAA_IP_RANGES` – comma- or space-separated IPs/CIDRs
- `OPSFOLIO_EAA_KEY_URLS` – comma- or space-separated URLs
- `OPSFOLIO_EAA_KEY_APIS` – comma- or space-separated APIs
- `OPSFOLIO_EAA_EXCLUDES` – comma- or space-separated exclusions
- `OPSFOLIO_EAA_KEY_GIT_URLS` - comma- or space-separated URLs
- `OPSFOLIO_EAA_CORSY_PATH` – (default: `/opt/eaa/Corsy`)
- `OPSFOLIO_EAA_WAF_BYPASS_PATH` – (default: `/opt/eaa/waf-bypass`)
- `OPSFOLIO_EAA_WP_TOKEN` – required string
- `OPSFOLIO_EAA_VIRUSTOTAL_API_KEY` – required string
- `OPSFOLIO_EAA_RATE_LIMIT` – (default: 200)
- `OPSFOLIO_EAA_CONCURRENCY` – (default: 50)
- `OPSFOLIO_EAA_NAABU_PORTS` – (default: top-100)
- `OPSFOLIO_EAA_NUCLEI_TEMPLATES` – (default: cves,default)

# Initialization and Logging

The runbook begins by creating a working directory for session data, evidence, and logs. It snapshots all Fleetfolio-related
environment variables so that the test configuration is preserved for auditability. The master log file is written to
`$OPSFOLIO_EAA_HOME/runbook.log`.

```bash init --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "Creates a working directory for session data, evidence, and logs"
#!/usr/bin/env bash
# Generate timestamp for the session folder
export OPSFOLIO_EAA_TIMESTAMP=$(date +'%Y-%m-%d-%H-%M-%S')

# Define dynamic output directory using the timestamp
export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"

# Create necessary directories
mkdir -p "$OPSFOLIO_EAA_SESSION_HOME"

# Initialize log file
LOG="$OPSFOLIO_EAA_SESSION_HOME/runbook.log"

# Snapshot Fleetfolio-related environment variables
(env | grep ^OPSFOLIO_EAA_ || true) | while read -r line; do
    echo "$line" | sed 's/\(.*\)=\(.*\)/\1="\2"/' >> "$OPSFOLIO_EAA_SESSION_HOME/arguments.env"
done

# Save timestamp explicitly in snapshot
echo "OPSFOLIO_EAA_TIMESTAMP=\"$OPSFOLIO_EAA_TIMESTAMP\"" >> "$OPSFOLIO_EAA_SESSION_HOME/arguments.env"

# Create a symlink (or file) that always points to the latest session
echo "$OPSFOLIO_EAA_TIMESTAMP" > /opt/eaa/latest-session

echo "[init] Session initialized at $OPSFOLIO_EAA_HOME" | tee -a "$LOG"
echo "[init] Snapshot written to $OPSFOLIO_EAA_SESSION_HOME/arguments.env" | tee -a "$LOG"
```

Artifacts: `$OPSFOLIO_EAA_SESSION_HOME/arguments.env` (environment variables in `key=value` format) and the master runbook log
at `$OPSFOLIO_EAA_SESSION_HOME/runbook.log`.

# Scope Normalization

Environment variables are convenient but not ideal for tool chaining. Here we normalize them into newline-delimited files so
each tool can consume scope easily.

```bash scope --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "Convert environment variables into newline files so tools can easily share scope"
#!/usr/bin/env bash
# Load .env configuration first
if [ -f .env ]; then
  echo "[INFO] .env file found in current dir, loading..."
  set -a
  . ./.env
  set +a
elif [ -f /opt/eaa/.env ]; then
  echo "[INFO] .env file found in /opt/eaa/, loading..." 
  set -a
  . /opt/eaa/.env
  set +a
else
  echo "[ERROR] .env file not found!"
  exit 1
fi

# Load the latest session reference
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Please run init first."
  exit 1
fi

# Verify session directory exists
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME not found!"
  exit 1
fi

# Create files safely inside the session
env > "$OPSFOLIO_EAA_SESSION_HOME/.env"
cp fleetfolio-eaa-pentest-lite.spry.md "$OPSFOLIO_EAA_SESSION_HOME" || true
cp directory-list.txt "$OPSFOLIO_EAA_SESSION_HOME" || true

# Normalize scope variables into text files
echo "${OPSFOLIO_EAA_TENANT_ID:-}"   | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/tenant_id.txt"
echo "${OPSFOLIO_EAA_TENANT_NAME:-}" | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/tenant_name.txt"
echo "${OPSFOLIO_EAA_PURPOSE:-}"     | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/purpose.txt"
echo "${OPSFOLIO_EAA_DESCRIPTION:-}" | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/description.txt"
echo "${OPSFOLIO_EAA_CONTEXT_JSON:-}"| tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/context.json"
echo "${OPSFOLIO_EAA_EXIT_EMAIL_ADDRESS:-}" | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/exit_email.txt"
echo "${OPSFOLIO_EAA_DOMAINS:-}"     | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/domains.txt"
echo "${OPSFOLIO_EAA_SUBDOMAINS:-}"  | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/subdomains.txt"
echo "${OPSFOLIO_EAA_CORSY_PATH:-}"  | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/corsy.txt"
echo "${OPSFOLIO_EAA_WAF_BYPASS_PATH:-}"  | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/waf-bypass.txt"
echo "${OPSFOLIO_EAA_WP_TOKEN:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/wp_token.txt"
echo "${OPSFOLIO_EAA_VIRUSTOTAL_API_KEY:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/virustotal_apikey.txt"
echo "${OPSFOLIO_EAA_IP_RANGES:-}"   | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/ip_ranges.txt"
echo "${OPSFOLIO_EAA_KEY_URLS:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"
echo "${OPSFOLIO_EAA_KEY_APIS:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/key_apis.txt"
echo "${OPSFOLIO_EAA_KEY_GIT_URLS:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/git_urls.txt"
echo "${OPSFOLIO_EAA_EXCLUDES:-}"    | tr ', ' '\n' | sed '/^$/d' > "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt"

echo "[scope] Session files written to $OPSFOLIO_EAA_SESSION_HOME" 
```
#### Scope and Normalization Using LHC-Forms

- Suppose you have an LHC Form; run this script to convert the LHC Form into environment variables.

```bash 
# Load jq to parse JSON (make sure jq is installed)
if ! command -v jq &> /dev/null
then
    echo "jq not found, please install jq to proceed."
    exit 1
fi

# File path
json_file="assessment.lhc-form.json"

# Extract required values from JSON using jq
TENANT_NAME=$(jq -r '.items[0].items[0].value' "$json_file")
DOMAINS=$(jq -r '.items[1].items[0].value' "$json_file")
IP_RANGES=$(jq -r '.items[2].items[0].value' "$json_file")
KEY_URLS=$(jq -r '.items[3].items[0].value' "$json_file")

# Export the values as environment variables
export OPSFOLIO_EAA_TENANT_NAME="$TENANT_NAME"
export OPSFOLIO_EAA_DOMAINS="$DOMAINS"
export OPSFOLIO_EAA_IP_RANGES="$IP_RANGES"
export OPSFOLIO_EAA_KEY_URLS="$KEY_URLS"

# Output the values (optional for verification)
echo "OPSFOLIO_EAA_TENANT_NAME: $OPSFOLIO_EAA_TENANT_NAME"
echo "OPSFOLIO_EAA_DOMAINS: $OPSFOLIO_EAA_DOMAINS"
echo "OPSFOLIO_EAA_IP_RANGES: $OPSFOLIO_EAA_IP_RANGES"
echo "OPSFOLIO_EAA_KEY_URLS: $OPSFOLIO_EAA_KEY_URLS"
```

Artifacts: text files under `$OPSFOLIO_EAA_SESSION_HOME` for domains, IP ranges, key URLs, and excludes.

## Subfinder – Discovering Subdomains

[Subfinder](https://github.com/projectdiscovery/subfinder) a subdomain discovery tool that uses passive online sources to quickly enumerate subdomains for a given domain. It’s widely used in reconnaissance to map the attack surface.

### Use Cases - Subfinder

- Discovering subdomains of a target organization during reconnaissance.
- Expanding attack surface before vulnerability scanning.
- Validating scope in bug bounty programs.

```yaml META
tool: 
  name: Subfinder
  provenance: https://github.com/projectdiscovery/subfinder
```

```bash subfinder --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "Quickly enumerate subdomains for a given domain"
#!/usr/bin/env bash
# Define output path for subfinder
# Load the latest session reference BEFORE we build output paths
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Please run init first."
  exit 1
fi

# Verify session directory exists
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME not found!" 
  exit 1
fi

# Now define output and input files (after OPSFOLIO_EAA_HOME is known)
OUT="$OPSFOLIO_EAA_HOME/subfinder/subfinder.jsonl"
mkdir -p "$(dirname "$OUT")"  # Ensure the output directory exists

DOMAINS_FILE="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"
SUBDOMAINS_FILE="$OPSFOLIO_EAA_SESSION_HOME/subdomains.txt"

# Log session path for debugging
echo "Session directory: $OPSFOLIO_EAA_SESSION_HOME" 

# Prepare input files if they exist in .env (safer splitting and trimming)
if [ -n "${OPSFOLIO_EAA_DOMAINS:-}" ]; then
  printf '%s\n' "$OPSFOLIO_EAA_DOMAINS" | tr ',; ' '\n' | sed '/^$/d' > "$DOMAINS_FILE"
fi

if [ -n "${OPSFOLIO_EAA_SUBDOMAINS:-}" ]; then
  printf '%s\n' "$OPSFOLIO_EAA_SUBDOMAINS" | tr ',; ' '\n' | sed '/^$/d' > "$SUBDOMAINS_FILE"
fi

# Case 1: Domains present → run subfinder as usual
if [ -s "$DOMAINS_FILE" ]; then
  while IFS= read -r DOMAIN; do
    # derive base domain naive (keep your original logic)
    BASE=$(echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}')
    if [ "$DOMAIN" = "$BASE" ]; then
      echo "[INFO] Running subfinder on $DOMAIN" 
      subfinder -d "$DOMAIN" -oJ -silent >> "$OUT" || true
    else
      # use dnsx -> jq approach for host lines (preserve your flow)
      echo "$DOMAIN" | dnsx -resp -silent | jq -R '{host:.}' >> "$OUT" || true
    fi
  done < "$DOMAINS_FILE"

# Case 2: No domains, but subdomains provided → just save them
elif [ -s "$SUBDOMAINS_FILE" ]; then
  while IFS= read -r SUB; do
    echo "[INFO] Saving subdomain: $SUB"
    echo "$SUB" | jq -R '{host:.}' >> "$OUT"
  done < "$SUBDOMAINS_FILE"
else
  echo "[ERROR] No domains or subdomains found!"
fi

echo "[subfinder] Output saved to $OUT" 

```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/subfinder/subfinder.jsonl`, one JSON record per subdomain discovered.

## dnsx – Resolving Hosts

[dnsx](https://github.com/projectdiscovery/dnsx) A fast and flexible DNS toolkit for running DNS queries. It can resolve hostnames, filter responses, and validate records, making it useful for verifying subdomain discoveries.

### Use Cases - dnsx

- Resolving subdomains found via Subfinder to check if they are alive.
- Performing DNS record lookups (A, CNAME, TXT, MX, etc.).
- Filtering valid domains from a large list.

```yaml META
tool: 
  name: dnsx
  provenance: https://github.com/projectdiscovery/dnsx
```

```bash dnsx --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A fast, flexible DNS tool for querying, filtering, and validating subdomains."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Please run init first."
  exit 1
fi

# Verify session directory exists
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME not found!" 
  exit 1
fi

# Define output path for dnsx
OUT="$OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl"
mkdir -p "$(dirname "$OUT")"

# Resolve all subdomains discovered by Subfinder
jq -r 'select(.host!=null) | .host' "$OPSFOLIO_EAA_HOME/subfinder/subfinder.jsonl" \
  | sed 's/ .*//' \
  | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
  | dnsx -json -silent -o "$OUT" || true

echo "[dnsx] Output saved to $OUT"
```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl` containing resolved IPs, CNAMEs, and other DNS data.

## httpx-toolkit – Probing Web Services

[httpx-toolkit](https://www.kali.org/tools/httpx-toolkit/) A fast HTTP toolkit that probes web servers to collect information such as status codes, titles, technologies, TLS details, redirects, and response headers. It helps identify live hosts and gather intelligence.  

### Use Cases - httpx-toolkit

- Checking which discovered subdomains are live.
- Collecting metadata (status codes, titles, headers, TLS details).
- Identifying web technologies for further exploitation.

```yaml META
tool: 
  name: httpx-toolkit
  provenance: https://www.kali.org/tools/httpx-toolkit/
```

```bash httpx-toolkit --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A fast HTTP tool for probing servers and gathering details like status, titles, tech, and headers."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi

# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl"

# Create the output directory if it does not exist
mkdir -p "$(dirname "$OUT")"

jq -r .host $OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl \
  | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
  > targets.txt || true

cat "$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt" >> targets.txt || true

httpx-toolkit -l targets.txt -json -silent \
  -rl "${OPSFOLIO_EAA_RATE_LIMIT:-200}" \
  -threads "${OPSFOLIO_EAA_CONCURRENCY:-50}" \
  -o "$OUT"
```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/httpx/httpx-toolkit.jsonl` with fields like URL, status code, title, webserver header.

## WhatWeb – Fingerprinting Technologies

[WhatWeb](https://github.com/urbanadventurer/WhatWeb) A web scanner that identifies websites’ technologies, frameworks, CMS, server details, and other metadata. It’s useful for fingerprinting applications during reconnaissance.  

### Use Cases - WhatWeb

- Detecting CMS (e.g., WordPress, Joomla, Drupal) in use.
- Identifying server-side technologies (Apache, Nginx, PHP, etc.).
- Profiling web applications for potential vulnerabilities.

```yaml META
tool: 
  name: WhatWeb
  provenance: https://github.com/urbanadventurer/WhatWeb
```

```bash whatweb --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A web scanner that identifies websites’ technologies, frameworks, CMS, server details, and other metadata."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
mkdir -p "$OPSFOLIO_EAA_HOME/whatweb"

# Extract URLs, remove excluded ones, remove duplicates
jq -r .url "$OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl" \
  | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
  | sort -u \
  | while read -r url; do
      safe=$(echo "$url" | sed 's#[/:?&=]#_#g')
      out="$OPSFOLIO_EAA_HOME/whatweb/$safe.json"

      # Only run if this output file hasn’t been created yet
      if [ ! -s "$out" ]; then
        whatweb --log-json="$out" "$url" || true
      fi
    done
```

Artifacts: per-target JSON files under `$OPSFOLIO_EAA_HOME/whatweb/whatweb.jsonl` with detected technologies.
The way to detect anomalies using WhatWeb findings include:

- Refer [whatweb-security-engineer.ctxe.md](./whatweb-security-engineer.ctxe.md)

## Naabu – Scanning Open Ports

[Naabu](https://github.com/projectdiscovery/naabu) A fast port scanner written in Go. It can scan large IP ranges to identify open ports, serving as a lightweight and high-performance alternative to traditional scanners.  

### Use Cases - Naabu

- Discovering open ports on a target system.
- Identifying exposed services (HTTP, SSH, FTP, etc.).
- Feeding live ports into service enumeration tools like Nmap.

```yaml META
tool: 
  name: Naabu
  provenance: https://github.com/projectdiscovery/naabu
```

```bash naabu --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A fast port scanner scans large IP ranges to identify open ports."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
mkdir -p $OPSFOLIO_EAA_HOME/naabu

jq -r .host $OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl \
  | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
  > naabu_hosts.txt || true

naabu -list naabu_hosts.txt -json -silent \
  -top-ports "${OPSFOLIO_EAA_NAABU_PORTS#top-}" \
  -rate "${OPSFOLIO_EAA_RATE_LIMIT:-200}" \
  -c "${OPSFOLIO_EAA_CONCURRENCY:-50}" \
  -o $OPSFOLIO_EAA_HOME/naabu/naabu.jsonl
```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/naabu/naabu.jsonl` with IP and port fields.

## Nmap – Service Enumeration

[Nmap](https://nmap.org/) One of the most popular and versatile network scanning tools. It detects open ports, services, versions, and even operating systems on target systems.  

### Use Cases - Nmap

- Performing comprehensive port scanning and service detection.
- Detecting operating systems and service versions.
- Running vulnerability detection scripts (via NSE).

```yaml META
tool: 
  name: Nmap
  provenance: https://nmap.org/
```

```bash nmap --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "It detects open ports, services, versions, and even operating systems on target systems."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
# Ensure output directory exists
mkdir -p "$OPSFOLIO_EAA_HOME/nmap"

# Extract unique IPs from naabu.jsonl into a temporary file
TARGETS_FILE="$OPSFOLIO_EAA_HOME/nmap/nmap_targets.txt"
jq -r .ip "$OPSFOLIO_EAA_HOME/naabu/naabu.jsonl" | sort -u > "$TARGETS_FILE"

# Run nmap with aggressive scan (-A), no ping (-Pn), faster timing (-T4)
# Output in normal format (-oN)
nmap -A -Pn -T4 -oX "$OPSFOLIO_EAA_HOME/nmap/nmap.xml" -iL "$TARGETS_FILE" || true

# Remove the temporary targets file
rm -f "$TARGETS_FILE"
```

Artifacts: XML and JSON representations of Nmap results at `$OPSFOLIO_EAA_HOME/nmap/nmap.xml`.

## OpenSSL – Inspecting TLS Certificates

[OpenSSL](https://www.openssl.org/) A robust toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It’s used to generate and manage keys/certificates, test SSL connections, and troubleshoot cryptographic issues.  

### Use Cases - OpenSSL

- Generating SSL/TLS certificates for secure communication.
- Testing SSL handshakes and debugging HTTPS issues.
- Checking for weak or expired certificates.

```yaml META
tool: 
  name: OpenSSL
  provenance: https://www.openssl.org/
```

```bash openssl --graph monthly --graph quarterly --graph annually --descr "A powerful tool for managing certificates, testing SSL/TLS, and fixing crypto issues."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
# Ensure directory exists
mkdir -p $OPSFOLIO_EAA_HOME/openssl

for host in $(jq -r .host $OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl \
              | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt"); do
  safe=$(echo "$host" | sed 's#[/:]#_#g')   # sanitize filename
  echo | openssl s_client -servername "$host" -connect "$host:443" -showcerts 2>/dev/null \
        > "$OPSFOLIO_EAA_HOME/openssl/$safe.txt" || true
done
```

Artifacts: plain text certificate details in `$OPSFOLIO_EAA_HOME/openssl/*.txt`.

## Nuclei – Template-Based Vulnerability Scanning

[Nuclei](https://github.com/projectdiscovery/nuclei) A fast vulnerability scanner that uses community-contributed templates to detect misconfigurations, CVEs, exposures, and other security issues. It automates large-scale scanning with customizable templates.  

### Use Cases - Nuclei

- Scanning web apps for known CVEs using templates.
- Detecting misconfigurations (e.g., exposed panels, default creds).
- Automating bug bounty reconnaissance workflows.

```yaml META
tool: 
  name: Nuclei
  provenance: https://github.com/projectdiscovery/nuclei
```

```bash nuclei --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A fast scanner using templates to find CVEs, misconfigs, and exposures."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
# Ensure output directory exists
mkdir -p "$OPSFOLIO_EAA_HOME/nuclei"

# Extract only the hostnames from httpx results and save to temporary targets file
jq -r .url "$OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl" \
  | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
  | sed -E 's,https?://([^/:]+).*,\1,' \
  | sort -u \
  > "$OPSFOLIO_EAA_HOME/nuclei/nuclei_targets.txt" || true

# Run nuclei against the extracted domains
nuclei -list "$OPSFOLIO_EAA_HOME/nuclei/nuclei_targets.txt" \
  -rate-limit "${OPSFOLIO_EAA_RATE_LIMIT:-200}" \
  -c "${OPSFOLIO_EAA_CONCURRENCY:-50}" \
  -jsonl-export "$OPSFOLIO_EAA_HOME/nuclei/nuclei.jsonl" || true

# Remove temporary targets file
rm -f "$OPSFOLIO_EAA_HOME/nuclei/nuclei_targets.txt"
```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/nuclei/nuclei.jsonl` with one result per finding.

## Katana – Crawling for Endpoints

[Katana](https://github.com/projectdiscovery/katana) A powerful web crawling tool designed to discover hidden files, endpoints, and parameters. It supports modern web technologies (like JS parsing) and is useful for application mapping and content discovery.  

### Use Cases - Katana

- Crawling target websites to find hidden endpoints.
- Extracting URLs and parameters for fuzzing.
- Mapping web applications for deeper testing.

```yaml META
tool: 
  name: Katana
  provenance: https://github.com/projectdiscovery/katana
```

```bash katana --graph weekly --graph monthly --graph quarterly --graph annually --descr "A powerful web crawling tool designed to discover hidden files, endpoints, and parameters."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
if command -v katana >/dev/null; then
  mkdir -p "$OPSFOLIO_EAA_HOME/katana"

  jq -r .url "$OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl" \
    | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
    > "$OPSFOLIO_EAA_HOME/katana/katana_targets.txt" 2>/dev/null || true

  katana \
    -list "$OPSFOLIO_EAA_HOME/katana/katana_targets.txt" \
    -jsonl \
    -silent \
    -o "$OPSFOLIO_EAA_HOME/katana/katana.jsonl" \
    >/dev/null 2>&1 || true

  # Cleanup temporary target file
  rm -f "$OPSFOLIO_EAA_HOME/katana/katana_targets.txt"
fi
```

Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/katana/katana.jsonl` listing discovered endpoints.

## tlsx – TLS Metadata Extraction

[tlsx](https://github.com/projectdiscovery/tlsx) A TLS/SSL scanner that helps analyze SSL certificates, extract metadata, and check for security issues in TLS configurations. It is valuable for identifying weak or misconfigured SSL setups.  

### Use Cases - TLSX

- Extracting SSL certificate details from multiple hosts.
- Identifying weak TLS versions or cipher suites.
- Monitoring certificate expiration across domains.

```yaml META
tool: 
  name: tlsx
  provenance: https://github.com/projectdiscovery/tlsx
```

```bash tlsx --graph weekly --graph monthly --graph quarterly --graph annually --descr "A TLS/SSL scanner for analyzing certificates and finding config issues."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
if command -v tlsx >/dev/null; then
  # Ensure output directory exists
  mkdir -p $OPSFOLIO_EAA_HOME/tlsx

  # Write targets inside the same folder
  jq -r .host $OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl \
    | grep -v -F -f "$OPSFOLIO_EAA_SESSION_HOME/excludes.txt" \
    > $OPSFOLIO_EAA_HOME/tlsx/tlsx_targets.txt || true

  # Only run if we have targets
  if [ -s $OPSFOLIO_EAA_HOME/tlsx/tlsx_targets.txt ]; then
    tlsx -list $OPSFOLIO_EAA_HOME/tlsx/tlsx_targets.txt \
         -silent  \
         -json -o $OPSFOLIO_EAA_HOME/tlsx/tlsx.jsonl || true
  else
    echo "[INFO] No TLSX targets found"
  fi
# Remove services.xml after conversion
rm -f $OPSFOLIO_EAA_HOME/tlsx/tlsx_targets.txt
fi
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/tlsx/tlsx.jsonl` with structured TLS details.

## Dirsearch – Directory Enumeration

[Dirsearch](https://www.kali.org/tools/dirsearch/) is an open-source command-line tool used for brute-forcing directories and files on web servers. It helps security testers and administrators discover hidden resources, misconfigured files, and sensitive endpoints that are not publicly linked. The tool supports multithreading, custom wordlists, recursive scans, proxy support, and can handle various HTTP methods, making it efficient for web application reconnaissance and vulnerability assessments.

### Use Cases - Dirsearch

- Hidden Path Discovery
- Exposure of Misconfigurations
- Recon in Pentesting

```yaml META
tool: 
  name: Dirsearch
  provenance: https://www.kali.org/tools/dirsearch/
```

```bash dirsearch --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool used for brute-forcing directories and files on web servers."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
if command -v dirsearch >/dev/null; then
  OUT="$OPSFOLIO_EAA_HOME/dirsearch/dirsearch.json"
  mkdir -p "$(dirname "$OUT")"

  KEY_URLS_FILE="$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"

  # Run dirsearch using the existing file
   dirsearch -l "$KEY_URLS_FILE" -i 200 --format=json -o "$OUT" 2>/dev/null || true
fi


```

- Artifacts: JSONL file at `/$OPSFOLIO_EAA_HOME/dirsearch/dirsearch.jsonl` with structured TLS details.

## wafw00f – Fingerprints Web Application Firewall (WAF)

[wafw00f](https://www.kali.org/tools/wafw00f/) WAFW00F is a Web Application Firewall (WAF) fingerprinting tool. It helps security testers and penetration testers detect whether a website is protected by a WAF and, if so, identify the specific vendor or technology in use. It works by sending crafted HTTP requests and analyzing responses to determine patterns that match known WAF behaviors.

### Use Cases - wafw00f

- Identify if a target application is protected by a WAF so that penetration testers can adjust their testing approach accordingly.
- Determine the specific WAF vendor (e.g., Cloudflare, Akamai, Imperva) to understand its protection mechanisms and known bypass techniques.
- Validate whether an organization has correctly deployed a WAF as part of regulatory compliance (e.g., PCI DSS) or general security hardening.

```yaml META
tool: 
  name: wafw00f
  provenance: https://www.kali.org/tools/wafw00f/
```

```bash wafw00f --graph monthly --graph quarterly --graph annually --descr "A Web Application Firewall (WAF) fingerprinting tool."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl"
OUT="$OPSFOLIO_EAA_HOME/wafw00f/wafw00f.txt"

mkdir -p "$(dirname "$OUT")"

# Run wafw00f on resolved hosts with timeout
jq -r 'select(.host!=null) | .host' "$IN" \
  | sort -u \
  | while read -r host; do
      wafw00f -a --no-colors "$host" || true
    done > "$OUT" || true
```

- Artifacts: JSONL file at `/$OPSFOLIO_EAA_HOME/wafw00f/wafw00f.jsonl` with structured TLS details.

## Testssl – SSL/TLS Security Testing Tool

[Testssl](https://github.com/testssl/testssl.sh) Testssl.sh is an open-source command-line tool used to test SSL/TLS configurations of servers.

### Use Cases - Testssl

- Detect weak or deprecated SSL/TLS protocols and ciphers.
- Identify SSL/TLS misconfigurations (e.g., insecure renegotiation, Heartbleed).

```yaml META
tool: 
  name: Testssl
  provenance: https://github.com/testssl/testssl.sh
```

```bash testssl --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool used to test SSL/TLS configurations of servers."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"
OUT="$OPSFOLIO_EAA_HOME/testssl/testssl.json"

mkdir -p "$(dirname "$OUT")"

# Corrected syntax
testssl --file "$IN" --jsonfile-pretty "$OUT"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/testssl/testssl.jsonl` with structured TLS details.

## Sqlmap – SSL/TLS Security Testing Tool

[Sqlmap](https://github.com/sqlmapproject/sqlmap) is an open-source penetration testing tool that automates the process of detecting and exploiting SQL injection vulnerabilities in web applications. It supports a wide range of databases and can help security testers identify and confirm database flaws quickly.

### Use Cases - Sqlmap

- Detect SQL Injection – Automatically test web applications for SQL injection vulnerabilities.
- Database Enumeration – Extract database names, tables, columns, and even data from vulnerable applications.
- Privilege Escalation & Access – Identify database users, check privileges, and attempt to gain administrative access to the backend.

```yaml META
tool: 
  name: Sqlmap
  provenance: https://github.com/sqlmapproject/sqlmap
```

```bash sqlmap --graph monthly --graph quarterly --graph annually --descr "A tool that automates the process of detecting and exploiting SQL injection vulnerabilities in web applications."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"
OUT="$OPSFOLIO_EAA_HOME/sqlmap/sqlmap.txt"

mkdir -p "$(dirname "$OUT")"

# Run sqlmap on each URL and append results to OUT
cat "$IN" | sort -u | while read -r url; do
    {
        echo "=================================================="
        echo "[*] Testing URL: $url"
        echo "=================================================="
        sqlmap --random-agent --batch \
               --current-user --current-db \
               -u "$url" || true
        echo
    } >> "$OUT"
done
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/sqlmap/sqlmap.txt` with structured TLS details.

## Subzy – Subdomain takeover

[Subzy](https://github.com/PentestPad/subzy) is an open-source tool used to detect and exploit subdomain takeover vulnerabilities. It scans for misconfigured subdomains pointing to deprovisioned services which works based on matching response fingerprints from [can-i-take-over-xyz](https://github.com/EdOverflow/can-i-take-over-xyz/blob/master/README.md).

### Use Cases - Subzy

- Identify subdomains vulnerable to takeover due to misconfigured DNS records.
- Automate reconnaissance during bug bounty or penetration testing.
- Prevent security risks by monitoring and fixing dangling subdomains in an organization.

```yaml META
tool: 
  name: Subzy
  provenance: https://github.com/PentestPad/subzy
```

```bash subzy --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool used to detect and exploit subdomain takeover vulnerabilities."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_HOME/subfinder/subfinder.jsonl"
TXT_OUT="$OPSFOLIO_EAA_HOME/subzy/subzy-temp.txt"
OUT="$OPSFOLIO_EAA_HOME/subzy/subzy.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Extract subdomains → save to TXT
jq -r '.host' "$IN" | sort -u > "$TXT_OUT"

# Run subzy → strip ANSI colors → save clean output
subzy run --targets "$TXT_OUT" \
  | sed -r "s/\x1B\[[0-9;]*[mK]//g" \
  > "$OUT"

# Remove TXT file after use
rm -f "$TXT_OUT"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/subzy/subzy.txt` with structured TLS details.

## Corsy – Cross Origin Resource Sharing Misconfiguration

[Corsy](https://github.com/s0md3v/Corsy/tree/master) is a lightweight program that scans for all known misconfigurations in CORS implementations.

### Use Cases - Corsy

- Detecting Insecure Wildcard Origins
- Identifying Trusted Subdomain Exploits
- Auditing Sensitive Endpoints for Data Leakage

```yaml META
tool: 
  name: Corsy
  provenance: https://github.com/s0md3v/Corsy/tree/master
```

```bash corsy --graph monthly --graph quarterly --graph annually --descr "A tool that scans for all known misconfigurations in CORS implementations."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/corsy/corsy.json"
IN="$OPSFOLIO_EAA_HOME/httpx-toolkit/httpx-toolkit.jsonl"
TEMP="$OPSFOLIO_EAA_HOME/corsy/corsy_temp.txt"
# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"
# Extract URLs from the httpx-toolkit.jsonl and append to the input
jq -r '
  select(.url != null and (.url | startswith("http"))) |
  .url
  | sub(":443$"; "")
  | sub(":80$"; "")
' "$IN" | sort -u > "$TEMP"

# Run Corsy with the extracted URLs
python3 $OPSFOLIO_EAA_CORSY_PATH/corsy.py -i "$TEMP" -o "$OUT"
```
- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/corsy/corsy.json` with structured TLS details.

## Nikto – Web server and CGI scanner

[Nikto](https://www.kali.org/tools/nikto/) is a pluggable web server and CGI scanner written in Perl, using rfp’s LibWhisker to perform fast security or informational checks.

### Use Cases - Nikto

- Available HTTP versions automatic switching
- Generic as well as specific server software checks
- SSL support (through libnet-ssleay-perl)

```yaml META
tool: 
  name: Nikto
  provenance: https://www.kali.org/tools/nikto/
```

```bash nikto --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool that checks for vulnerabilities, outdated software, misconfigurations, and dangerous files."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/nikto/nikto.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Run nikto (continue even if it errors)
nikto --host "$IN" -output "$OUT" || echo "Nikto scan failed, continuing..."
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/nikto/nikto.txt` with structured TLS details.

## WPScan – WordPress Security Scanner

[WPScan](https://www.kali.org/tools/wpscan/) target WordPress URL and enumerate any plugins that are installed.

### Use Cases - WPScan

- Available HTTP versions automatic switching
- Generic as well as specific server software checks
- SSL support (through libnet-ssleay-perl)

```yaml META
tool: 
  name: WPScan
  provenance: https://www.kali.org/tools/wpscan/
```

```bash wpscan --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool that scans WordPress for vulnerabilities, outdated plugins, and misconfigurations."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/wpscan/wpscan.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/key_urls.txt"
TOKEN="$OPSFOLIO_EAA_SESSION_HOME/wp_token.txt"
# Read token contents (strip CR/newline)
TOKEN="$(tr -d '\r\n' < "$OPSFOLIO_EAA_SESSION_HOME/wp_token.txt")"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Run WPScan for each domain listed in IN (one JSON per domain)
while IFS= read -r url || [ -n "$url" ]; do
  [ -z "$url" ] && continue
  safe="$(echo "$url" | sed 's/[^A-Za-z0-9._-]/_/g')"
  wpscan --url "$url" --api-token "$TOKEN" --enumerate u --random-user-agent --format JSON -o "$OUT"
done < "$IN" || echo "wpscan scan failed, continuing..."

```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/wpscan/wpscan.json` with structured TLS details.

## RustScan – Modern Port Scanner

[RustScan](https://github.com/bee-san/RustScan) is a modern take on the port scanner. Sleek & fast. All while providing extensive extendability to you.

### Use Cases - RustScan

- Scans all 65k ports in 3 seconds.
- Full scripting engine support. Automatically pipe results into Nmap, or use our scripts (or write your own) to do whatever you want.
- Adaptive learning. RustScan improves the more you use it. No bloated machine learning here, just basic maths.

```yaml META
tool: 
  name: RustScan
  provenance: https://github.com/bee-san/RustScan
```

```bash rustscan --graph monthly --graph quarterly --graph annually --descr "A fast port scanner that quickly identifies open ports."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/rustscan/rustscan.txt"
IN="$OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl"
TEMP="$OPSFOLIO_EAA_HOME/rustscan/rustscan-temp.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Extract hostnames into a temp file
jq -r '.host' "$IN" > "$TEMP"

# Run rustscan with host list
rustscan -a "$TEMP" --ulimit 5000 -t 2000 > "$OUT"

# Clean up temp file
rm -f "$TEMP"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/rustscan/rustscan.txt` with structured TLS details.

## Amass – Network Mapping

[Amass](https://www.kali.org/tools/amass/)  performs network mapping of attack surfaces and external asset discovery using open source information gathering and active reconnaissance techniques.

### Use Cases - Amass

- Subdomain Enumeration
- Attack Surface Discovery and Mapping
- External Asset Inventory and Monitoring

```yaml META
tool: 
  name: Amass
  provenance: https://www.kali.org/tools/amass/
```

```bash amass --graph monthly --graph quarterly --graph annually --descr "A tool for discovering subdomains, mapping attack surfaces, and gathering DNS intelligence."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/amass/amass.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

mkdir -p "$(dirname "$OUT")"

while read -r domain; do
    amass enum -d "$domain" -o "$OUT"
done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/amass/amass.txt` with structured TLS details.

## DNSEnum – Network Mapping

[DNSEnum](https://www.kali.org/tools/dnsenum/) is a multithreaded perl script to enumerate DNS information of a domain and to discover non-contiguous ip blocks. The main purpose of Dnsenum is to gather as much information as possible about a domain.

### Use Cases - DNSEnum

- Discover hosts, subdomains, and DNS records (A, MX, NS, zone transfers).
- Perform network enumeration and lookups (C-class ranges, whois, reverse DNS).
- Save and document discovered IPs and assets.

```yaml META
tool: 
  name: DNSEnum
  provenance: https://www.kali.org/tools/dnsenum/
```

```bash dnsenum --graph monthly --graph quarterly --graph annually --descr "A tool for enumerating DNS informations of a domain and to discover non-contiguous ip blocks."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/dnsenum/dnsenum.xml"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Run dnsenum for each domain and append output
> "$OUT"  # Clear output file
while read -r domain; do

  dnsenum "$domain" -o "$OUT" \
    > /dev/null 2>&1 || echo "⚠️ dnsenum failed for $domain"
done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/dnsenum/dnsenum.txt` with structured TLS details.

## TheHarvester – Network Mapping

[TheHarvester](https://www.kali.org/tools/theharvester/) is a tool for gathering subdomain names, e-mail addresses, virtual hosts, open ports/ banners, and employee names from different public sources (search engines, pgp key servers).

### Use Cases - TheHarvester

- Email and Employee Harvesting
- Subdomain and Host Discovery
- Metadata and Open-Source Intelligence Collection

```yaml META
tool: 
  name: TheHarvester
  provenance: https://www.kali.org/tools/theharvester/
```

```bash theharvester --graph monthly --graph quarterly --graph annually --descr "An OSINT tool that gathers subdomains, emails, hosts, and employee info from public sources."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/theharvester/theharvester.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Loop through each domain
while IFS= read -r domain; do

  theHarvester -d "$domain" -b yahoo -f "$OUT" 
  rm "$OPSFOLIO_EAA_HOME/theharvester/theharvester.xml"

done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/theharvesterum/theharvester.json` with structured TLS details.

## ParamSpider – Automating advanced SQL injection attacks

[Paramspider](https://github.com/devanshbatham/ParamSpider) allows you to fetch URLs related to any domain or a list of domains from Wayback achives. It filters out "boring" URLs, allowing you to focus on the ones that matter the most.

### Use Cases - ParamSpider

- Discover hidden URL parameters
- Expand attack surface
- Support automated vulnerability testing

```yaml META
tool: 
  name: ParamSpider
  provenance: https://github.com/devanshbatham/ParamSpider
```

```bash paramspider --graph monthly --graph quarterly --graph annually --descr "A tool allows you to fetch URLs related to any domain or a list of domains from Wayback achives."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/paramspider/paramspider.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

# Loop through each domain in the input file
while read -r domain; do
    echo "[*] Running ParamSpider for $domain"

    # Run ParamSpider for the domain
    paramspider -d "$domain"

    # Move the results file to the final output path
    if [ -f "results/${domain}.txt" ]; then
        mv "results/${domain}.txt" "$OUT"
        echo "[*] Results moved to $OUT"
    else
        echo "[!] No results found for $domain"
    fi
done < "$IN"

```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/paramspider/paramspider.txt` with structured TLS details.

## Ghauri – Automating advanced SQL injection attacks

[Ghauri](https://github.com/r0oth3x49/ghauri) is an advanced cross-platform tool that automates the process of detecting and exploiting SQL injection security flaws.It supports multiple injection types (boolean, error-based, time-based, stacked queries, etc.) and works with various databases like MySQL, PostgreSQL, MSSQL, Oracle, etc. It also supports attacking via GET/POST, headers, JSON, SOAP/XML, allows using proxies, custom payloads, skip encoding, session resume, and more.

### Use Cases - Ghauri

- Identify SQL injection vulnerabilities
- Enumerate database structure and extract sensitive data
- Leverage SQL injection for privilege escalation

```yaml META
tool: 
  name: Ghauri
  provenance: https://github.com/r0oth3x49/ghauri
```

```bash ghauri --graph monthly --graph quarterly --graph annually --descr "A tool that automates the process of detecting and exploiting SQL injection security flaws."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/ghauri/ghauri.txt"
IN="$OPSFOLIO_EAA_HOME/paramspider/paramspider.txt"

# Ensure output directory exists
mkdir -p "$(dirname "$OUT")"

ghauri -m "$IN" --batch --current-user --current-db --hostname > "$OUT" 2>&1
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/ghauri/ghauri.txt` with structured TLS details.

## cdncheck – CDN Detection Tool

[cdncheck](https://github.com/projectdiscovery/cdncheck) is a command-line utility developed by ProjectDiscovery designed to identify whether a given IP address belongs to known Content Delivery Network (CDN) providers, such as Akamai, Cloudflare, Incapsula, Sucuri, and Leaseweb.

### Use Cases - cdncheck

- Check if target is behind a CDN.
- Understand infrastructure for risk evaluation.
- Trace traffic origin and content distribution during breaches.

```yaml META
tool: 
  name: cdncheck
  provenance: https://github.com/projectdiscovery/cdncheck
```

```bash cdncheck --graph monthly --graph quarterly --graph annually --descr "A tool that identifies if an IP belongs to a known CDN provider."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_HOME/dnsx/dnsx.jsonl"
OUT="$OPSFOLIO_EAA_HOME/cdncheck/cdncheck.jsonl"

mkdir -p "$(dirname "$OUT")"

# Extract only the host values from dnsx.jsonl and pass to cdncheck
jq -r '.host' "$IN" | cdncheck -j > "$OUT"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/cdncheck/cdncheck.jsonl` with structured TLS details.

## FFUF – Fast Web Fuzzer

[FFUF](https://www.kali.org/tools/ffuf/) is a fast web fuzzer written in Go, used for discovering hidden files, directories, and parameters.
It supports fuzzing GET/POST data, virtual hosts, and headers with high performance. Commonly used in web penetration testing to identify undisclosed endpoints or functionalities.

### Use Cases - FFUF

- Hidden directory & file enumeration
- Virtual host (vhost) discovery via Host header fuzzing
- Parameter fuzzing for GET/POST endpoints

```yaml META
tool: 
  name: FFUF
  provenance: https://www.kali.org/tools/ffuf/
```

```bash ffuf --graph monthly --graph quarterly --graph annually --descr "A tool used for identifying hidden files, directories, and parameters."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/ffuf/ffuf.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"
WORDLIST="$OPSFOLIO_EAA_SESSION_HOME/directory-list.txt"

mkdir -p "$(dirname "$OUT")"

while read -r domain; do
    case "$domain" in
        http* ) ;;
        * ) domain="https://$domain" ;;
    esac

    echo "Running ffuf for $domain ..."
    ffuf -u "$domain/FUZZ" -w "$WORDLIST" -mc 200 -t 10 -p 0.2 -json -o "$OUT"
done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/ffuf/ffuf.jsonl` with structured TLS details.

## Dalfox – Fast Web Fuzzer

[Dalfox](https://github.com/hahwul/dalfox) is a powerful open-source tool that focuses on automation, making it ideal for quickly scanning for XSS flaws and analyzing parameters. Its advanced testing engine and niche features are designed to streamline the process of detecting and verifying vulnerabilities.

### Use Cases - Dalfox

- Discovery: Parameter analysis, static analysis, BAV testing, parameter mining
- XSS Scanning: Reflected, Stored, DOM-based, with optimization and DOM/headless verification
- HTTP Options: Custom headers, cookies, methods, proxy, and more

```yaml META
tool: 
  name: Dalfox
  provenance: https://github.com/hahwul/dalfox
```

```bash dalfox --graph monthly --graph quarterly --graph annually --descr "A tool used for identifying XSS flaws and analyzing parameters."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/dalfox/dalfox.jsonl"
IN="$OPSFOLIO_EAA_HOME/paramspider/paramspider.txt"

mkdir -p "$(dirname "$OUT")"

dalfox file "$IN" --format jsonl > "$OUT" 
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/dalfox/dalfox.jsonl` with structured TLS details.

## SSLyze – Fast Web Fuzzer

[SSLyze](https://www.kali.org/tools/sslyze/) is a Python tool that can analyze the SSL configuration of a server by connecting to it. It is designed to be fast and comprehensive, and should help organizations and testers identify misconfigurations affecting their SSL servers.

### Use Cases - SSLyze

- It is a battle-tested tool that is used to reliably scan hundreds of thousands of servers every day.
- It can be directly run from CI/CD, in order to continuously check a server against Mozilla's recommended TLS configurations.
- Support for scanning non-HTTP servers including SMTP, XMPP, LDAP, POP, IMAP, RDP, Postgres and FTP servers.

```yaml META
tool: 
  name: SSLyze
  provenance: https://www.kali.org/tools/sslyze/
```

```bash sslyze --graph monthly --graph quarterly --graph annually --descr "A tool for analyzing SSL configurations and finding server misconfigurations."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/sslyze/sslyze.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

mkdir -p "$(dirname "$OUT")"

echo "[" > "$OUT"
first_entry=1

while read -r domain; do
  # Skip empty lines or lines starting with #
  case "$domain" in
    ""|\#*) continue ;;
  esac

  tmp_out=$(mktemp)

  # Run sslyze silently (send stdout to /dev/null)
  if command -v sslyze >/dev/null 2>&1; then
    sslyze "$domain" --slow_connection --json_out="$tmp_out" >/dev/null 2>&1 || true
  else
    echo "ERROR: sslyze not found in PATH" >&2
    rm -f "$tmp_out"
    continue
  fi

  if [ "$first_entry" -eq 1 ]; then
    first_entry=0
  else
    echo "," >> "$OUT"
  fi

  cat "$tmp_out" >> "$OUT"
  rm -f "$tmp_out"

done < "$IN"

echo "]" >> "$OUT"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/sslyze/sslyze.jsonl` with structured TLS details.

## Misconfig-Mapper - Enumerate Misconfigurations

[Misconfig-Mapper](https://github.com/intigriti/misconfig-mapper) is a project by Intigriti for the community to help you find, detect and resolve common security misconfigurations in various popular services, technologies and SaaS-based solutions that your targets use.

### Use Cases - Misconfig-Mapper

- Cloud and infrastructure misconfiguration scanner by Intigriti
- Supports AWS, Azure, GCP, Kubernetes, and Docker environment checks
- Provides rule-based scanning with verbosity control and mapped industry standards

```yaml META
tool: 
  name: Misconfig-Mapper
  provenance: https://github.com/intigriti/misconfig-mapper
```

```bash misconfig_mapper --graph monthly --graph quarterly --graph annually --descr "A tool for identifying security misconfigurations across cloud and infrastructure systems."
#!/usr/bin/env bash

# Ensure we are running bash and not something else
if [ -z "$BASH_VERSION" ]; then
  echo "[ERROR] This script must be run with Bash!" >&2
  exit 1
fi

if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# Sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi

# --------------------------------------------------

OUT="$OPSFOLIO_EAA_HOME/misconfig_mapper/misconfig_mapper.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

# Ensure the output file path is valid
mkdir -p "$(dirname "$OUT")"

# Check if jq is available
if ! command -v jq &> /dev/null; then
  echo "[ERROR] jq is not installed. Please install jq." >&2
  exit 1
fi

# Check if misconfig-mapper is available
if ! command -v misconfig-mapper &> /dev/null; then
  echo "[ERROR] misconfig-mapper is not installed. Please install misconfig-mapper." >&2
  exit 1
fi

# Process domains
while read -r domain; do
  [ -n "$domain" ] || continue
  misconfig-mapper -target "$domain" -service "*" -verbose 0 -output-json >> "$OUT"
done < "$IN"

echo "[INFO] Misconfig mapping complete. Results stored in $OUT."

```
- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/misconfig_mapper/misconfig_mapper.json` with structured TLS details.

## SMTP-User-Enum - Enumerate SMTP Usernames 

[SMTP-User-Enum](https://www.kali.org/tools/smtp-user-enum/) is a username guessing tool primarily for use against the default Solaris SMTP service. Can use either EXPN, VRFY or RCPT TO.

### Use Cases - SMTP-User-Enum

- Enumerates valid SMTP users by probing mail servers via VRFY, EXPN, or RCPT commands.
- Helps identify existing email accounts for penetration testing and user mapping.
- Supports multiple enumeration modes and can run against single or bulk targets.

```yaml META
tool: 
  name: SMTP-User-Enum
  provenance: https://www.kali.org/tools/smtp-user-enum/
```

```bash smtp-user-enum --graph monthly --graph quarterly --graph annually --descr "An username guessing tool primarily for use against the default Solaris SMTP service."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------

OUT="$OPSFOLIO_EAA_HOME/smtp-user-enum/smtp-user-enum.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"
USER="/usr/share/seclists/Usernames/top-usernames-shortlist.txt"

mkdir -p "$(dirname "$OUT")"

while IFS= read -r domain; do
  [ -n "$domain" ] || continue
  smtp-user-enum -M VRFY -U "$USER" -t "$domain" > "$OUT" 2>&1 || true
done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/smtp-user-enum/smtp-user-enum.txt` with structured TLS details.

## Fierce - DNS reconnaissance tool

[Fierce](https://github.com/mschwager/fierce) is a DNS reconnaissance tool for locating non-contiguous IP space.

### Use Cases - Fierce

- A DNS reconnaissance tool designed to find non-contiguous IP space and hostname mappings for a given domain. 
GitHub
- Can perform subdomain sweeps, zone transfers, and IP block traversals to reveal exposed network ranges. 
GitHub
- Intended as a pre-scanner (before tools like nmap or Nikto) for infrastructure reconnaissance—not for exploitation.

```yaml META
tool: 
  name: Fierce
  provenance: https://github.com/mschwager/fierce
```

```bash fierce --graph monthly --graph quarterly --graph annually --descr "A DNS reconnaissance tool for locating non-contiguous IP space."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------

OUT="$OPSFOLIO_EAA_HOME/fierce/fierce.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

mkdir -p "$(dirname "$OUT")"

while IFS= read -r domain; do
  [ -n "$domain" ] || continue
  fierce --domain "$domain" >> "$OUT" 2>&1 || true
done < "$IN"
```

- Artifacts: JSONL file at `$OPSFOLIO_EAA_HOME/fierce/fierce.txt` with structured TLS details.

## Virustotal - Domain Intelligence Tool

[Virustotal](https://www.virustotal.com/) is a platform that helps map an internet asset by identifying subdomains and their associated IP addresses, revealing the domain’s external footprint. It also provides hash values for files submitted or discovered during scans—enabling verification and deeper malware analysis—and lists URLs that have been observed or scanned for the queried domain to support threat hunting and triage.

### Use Cases - Virustotal

- Easily identify subdomains and associated IPs.
- Retrieve hash values for uploaded files and their contents.
- Obtain the set of URLs that have been scanned for the entered domain.

```yaml META
tool: 
  name: Virustotal
  provenance: https://www.virustotal.com/
```

```bash virustotal --graph monthly --graph quarterly --graph annually --descr "A Domain Intelligence Tool for identifying subdomains and their associated IP addresses."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------

OUT="$OPSFOLIO_EAA_HOME/virustotal/virustotal.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"
APIKEY="$OPSFOLIO_EAA_SESSION_HOME/virustotal_apikey.txt"

mkdir -p "$(dirname "$OUT")"

while read -r key; do
    while read -r domain; do
        curl -s "https://www.virustotal.com/vtapi/v2/domain/report?apikey=$key&domain=$domain" | jq . > "$OUT"
    done < "$IN"
done < "$APIKEY"

```

- Artifacts: JSON file at `$OPSFOLIO_EAA_HOME/virustotal/virustotal.json` with structured TLS details.

## VulnAPI - Detect API Security Vulnerabilities

[VulnAPI](https://github.com/cerberauth/vulnapi) is an Open-Source DAST designed to help you scan your APIs for common security vulnerabilities and weaknesses. By using this tool, you can detect and mitigate security vulnerabilities in your APIs before they are exploited by attackers.

### Use Cases - VulnAPI

- Scanning a RESTful API during your pentest to detect misconfigurations (e.g., missing CORS, missing security headers).
- Automating API security checks in your CI/CD pipeline (scan via OpenAPI contract before deployment).
- Performing discovery on an unknown API surface to identify exposed endpoints, JWT misuse or leaked files.

```yaml META
tool: 
  name: VulnAPI
  provenance: https://github.com/cerberauth/vulnapi
```

```bash vulnapi --graph monthly --graph quarterly --graph annually --descr "An API security vulnerability scanner."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/vulnapi/vulnapi.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/key_apis.txt"

mkdir -p "$(dirname "$OUT")"

# Ensure we have at least one target API URL
if [ ! -s "$IN" ]; then
  echo "[ERROR] $IN is empty. Set OPSFOLIO_EAA_KEY_APIS to at least one API URL." >&2
  exit 1
fi

# Take the first non-empty, non-comment line as the API URL
API_URL="$(grep -vE '^\s*#' "$IN" | sed '/^\s*$/d' | head -n 1)"

if [ -z "$API_URL" ]; then
  echo "[ERROR] No valid API URL found in $IN." >&2
  exit 1
fi

# Run VulnAPI against the URL
vulnapi scan curl "$API_URL" > "$OUT"

```

- Artifacts: JSON file at `$OPSFOLIO_EAA_HOME/vulnapi/vulnapi.txt` with structured TLS details.

## Commix – Automated Command Injection Exploitation Tool

[Commix](https://github.com/commixproject/commix) is an open-source tool used to detect and exploit command injection vulnerabilities in web applications. It automates both discovery and exploitation, making it highly useful during web security assessments.

### Use Cases - Commix

- Identify command injection flaws in parameters, forms, cookies, or HTTP headers.  
- Automate exploitation to validate impact (e.g., command execution, reverse shells).  
- Test multiple injection points quickly during web app pentesting or bug bounty assessments.

```yaml META
tool: 
  name: Commix
  provenance: https://github.com/commixproject/commix
```

```bash commix --graph monthly --graph quarterly --graph annually --descr "An Automated Command Injection Exploitation Tool."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------

OUT="$OPSFOLIO_EAA_HOME/commix/commix.txt"
IN="$OPSFOLIO_EAA_HOME/paramspider/paramspider.txt"

mkdir -p "$(dirname "$OUT")"

# Check if the paramspider.txt exists and is not empty
if [ ! -s "$IN" ]; then
  echo "[ERROR] $IN is empty or does not exist! Please ensure ParamSpider is run first." >&2
  exit 1
fi

echo "[*] Running Commix with the input from $IN"

# Run Commix
while IFS= read -r url; do
commix -m "$IN" --batch --current-user --hostname --answers="shell=N" > "$OUT"
done < "$IN"
```

- Artifacts: JSON file at `$OPSFOLIO_EAA_HOME/commix/commix.txt` with structured TLS details.

## WAF-Bypass – Automated Web Application Firewall Evasion Tool

[WAF-Bypass](https://github.com/nemesida-waf/waf-bypass) is an open-source tool designed to identify weaknesses in Web Application Firewalls (WAFs) and attempt to bypass their filtering mechanisms. It helps security testers understand how certain payloads can evade protection layers, making it valuable for web security assessments.

### Use Cases - WAF-Bypass

- Evaluate how well a WAF detects and blocks malicious payloads.  
- Test different evasion techniques against WAF-protected endpoints.  
- Identify weak filtering patterns or misconfigurations in WAF rules.  
- Validate whether common attack vectors (SQLi, XSS, RCE payloads, etc.) can bypass deployed security controls.  
- Enhance pentesting workflows by automating WAF evasion attempts during reconnaissance and exploitation phases.

```yaml META
tool: 
  name: WAF-Bypass
  provenance: https://github.com/nemesida-waf/waf-bypass
```

```bash waf-bypass --graph monthly --graph quarterly --graph annually --descr "An Automated waf-bypass detection tool."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/waf-bypass/waf-bypass.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/domains.txt"

# Create output directory (not the file)
mkdir -p "$(dirname "$OUT")"

while read -r domain; do
    python3 "$OPSFOLIO_EAA_WAF_BYPASS_PATH"/main.py --host="$domain" >> "$OUT"
done < "$IN"
```
- Artifacts: TXT file at `$OPSFOLIO_EAA_HOME/waf_bypass/waf_bypass.txt` with structured TLS details.

## Trivy – Unified Vulnerability & Misconfiguration Scanner

[Trivy](https://github.com/aquasecurity/trivy) is an open-source, fast, and comprehensive security scanner that detects vulnerabilities, misconfigurations, secrets, and license issues across multiple targets. It is widely used in DevSecOps pipelines and security assessments due to its simple CLI interface and broad coverage.

### Use Cases - Trivy

- Scan code, filesystems, and repositories for vulnerabilities and hardcoded secrets.
- Identify CVEs in application dependencies, packages, and container images.
- Detect security misconfigurations in IaC files like Dockerfiles, Kubernetes manifests, and Terraform.

```yaml META
tool: 
  name: Trivy
  provenance: https://github.com/aquasecurity/trivy
```

```bash trivy --graph monthly --graph quarterly --graph annually --descr "A Vulnerability & Misconfiguration Scanner."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/trivy/trivy.txt"
IN="$OPSFOLIO_EAA_SESSION_HOME/git_urls.txt"

# Create output directory
mkdir -p "$(dirname "$OUT")"

# Read each URL from git_urls.txt and run Trivy on it
while IFS= read -r repo_url; do
  # Skip empty lines or comments
  [ -z "$repo_url" ] || [[ "$repo_url" =~ ^# ]] && continue

  # Run Trivy on the repo URL and append the results to the output file
  trivy repo "$repo_url" >> "$OUT"
done < "$IN"

```
- Artifacts: TXT file at `$OPSFOLIO_EAA_HOME/trivy/trivy.txt` with structured TLS details.


## Vet – Supply chain security analysis for CI/CD pipelines

[Vet](https://docs.safedep.io/introduction) is an open-source software supply chain security tool that helps developers and security engineers detect malicious packages, prioritize real dependency risks through usage-aware SCA, and enforce security requirements using policy-as-code with CEL expressions.

### Use Cases - Vet

- Real-time malicious package detection — Active scanning and analysis of unknown packages
- Modern SCA with actual usage analysis — Prioritize real risks over vulnerability noise
- Policy as Code — Express security requirements using [CEL](https://cel.dev/) expressions

```yaml META
tool: 
  name: Vet
  provenance: https://docs.safedep.io/introduction
```

```bash vet --graph monthly --graph quarterly --graph annually --descr "A Supply chain security analysis for CI/CD pipelines."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP="$(cat /opt/eaa/latest-session)"
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
OUT="$OPSFOLIO_EAA_HOME/vet/vet.json"
IN="$OPSFOLIO_EAA_SESSION_HOME/git_urls.txt"

mkdir -p "$(dirname "$OUT")"

vet scan \
  --github "$(cat "$IN")" \
  --report-json "$OUT"

```
- Artifacts: TXT file at `$OPSFOLIO_EAA_HOME/vet/vet.json` with structured TLS details.

## Convert Results into SQLite Database with Surveilr

After the scanning process, the collected results are normalized and stored in a single SQLite database file named resource-surveillance.sqlite.db. This step ensures that all findings are structured, queryable, and ready for further analysis or reporting through Surveilr.

```bash surveilr --graph daily --graph weekly --graph monthly --graph quarterly --graph annually --descr "A tool for converting any files or folders into a SQLite database file."
#!/usr/bin/env bash
if [ -f /opt/eaa/latest-session ]; then
  export OPSFOLIO_EAA_TIMESTAMP=$(cat /opt/eaa/latest-session)
  export OPSFOLIO_EAA_HOME="/opt/eaa/sessions/$OPSFOLIO_EAA_TIMESTAMP"
  export OPSFOLIO_EAA_SESSION_HOME="$OPSFOLIO_EAA_HOME/.session"
else
  echo "[ERROR] /opt/eaa/latest-session not found! Run init first." >&2
  exit 1
fi

# sanity checks
if [ ! -d "$OPSFOLIO_EAA_SESSION_HOME" ]; then
  echo "[ERROR] Session directory $OPSFOLIO_EAA_SESSION_HOME does not exist!" >&2
  exit 1
fi
# --------------------------------------------------
IN="$OPSFOLIO_EAA_HOME"
OUT="$OPSFOLIO_EAA_HOME"
TENANT_ID_FILE="$OPSFOLIO_EAA_SESSION_HOME/tenant_id.txt"

# Extract timestamp from OPSFOLIO_EAA_HOME
timestamp="$(basename "$OPSFOLIO_EAA_HOME")"

# Read tenant ID
tenant_id="$(cat "$TENANT_ID_FILE")"

# Ensure timestamp directory exists
if [ ! -d "$OPSFOLIO_EAA_HOME" ]; then
  echo "[!] Timestamp directory not found: $OPSFOLIO_EAA_HOME"
  exit 1
fi

# Move into the timestamp directory
cd "$OPSFOLIO_EAA_HOME" || exit 1

# Run ingest INSIDE timestamp folder
surveilr ingest files -r . \
  --tenant-id "$tenant_id" \
  --tenant-name "$OPSFOLIO_EAA_TENANT_NAME" \
  --state-db-fs-path "$OUT/${tenant_id}-${timestamp}.opsfolio-eaa-rssd.sqlite.db"

# Zip the generated DB
zip -r "$OUT/${tenant_id}-${timestamp}.opsfolio-eaa-rssd.sqlite.db.zip" \
  "$OUT/${tenant_id}-${timestamp}.opsfolio-eaa-rssd.sqlite.db"

```
- Artifacts: SQLite file located at `$OPSFOLIO_EAA_HOME/*.opsfolio-eaa-rssd.sqlite.db`, containing a uniform resources table.

# Analyst’s Guide to Interpreting Artifacts

This appendix provides practical advice for reviewing the artifacts generated by each tool. It is meant for analysts who may
not be familiar with the nuances of every tool but need to make sense of the outputs.

#### Subfinder (`subfinder.jsonl`)

Each line is a JSON object with a `host` field and the `source` where it was discovered. Analysts should look for:

- Subdomains that are unexpected or unmanaged.
- Entries that do not resolve later in dnsx, which may indicate legacy or abandoned records.

#### dnsx (`dnsx.jsonl`)

DNS resolution results will include IPs (A/AAAA records), CNAMEs, and other metadata. Analysts should:

- Verify that IPs map to owned infrastructure.
- Flag any pointing to cloud or third-party networks that might be unmanaged.

#### httpx-toolkit (`httpx-toolkit.jsonl`)

Contains metadata for live web services: status codes, titles, server headers. Analysts should:

- Look for sensitive endpoints (e.g., admin panels, login portals).
- Pay attention to unusual server headers or technologies that don’t align with policy.

#### WhatWeb (`whatweb/*.json`)

Per-target JSON files list detected plugins/technologies. Analysts should:

- Identify outdated CMS or frameworks (e.g., old WordPress, Joomla).
- Cross-check detected versions against known vulnerabilities.

#### Naabu (`naabu.jsonl`)

JSON lines listing IPs and open ports. Analysts should:

- Spot unexpected open ports (e.g., databases, RDP, SSH exposed externally).
- Focus on high-risk services like SMB, Telnet, or legacy protocols.

#### Nmap (`nmap.xml`)

Provides enriched service banners and versions. Analysts should:

- Confirm the accuracy of Naabu findings.
- Evaluate service versions for end-of-life software.

#### OpenSSL (`tls/*.txt`)

Raw transcripts of TLS handshakes and certificate chains. Analysts should:

- Check expiry dates, SAN entries, and certificate issuers.
- Flag self-signed or weakly signed certificates.

#### Nuclei (`nuclei.txt`)

Each JSON line represents a finding matched against a template. Analysts should:

- Sort by severity to prioritize triage.
- Validate important findings manually before reporting.

#### Katana (`katana.jsonl`)

Lists discovered web endpoints through crawling. Analysts should:

- Look for API endpoints, hidden admin paths, or sensitive resources.
- Cross-reference endpoints against vulnerability scan coverage.

#### Dirsearch (`dirsearch.json`)

Structured Dirsearch scan results including discovered directories, files, and HTTP response codes. Analysts should:

- Use this to identify hidden or sensitive directories and files on the target.
- Review discovered paths for potential misconfigurations or exposure of sensitive data.

#### wafw00f (`wafw00f.txt`)

Structured WAFW00F results identifying web application firewalls (WAFs) deployed on the target. Analysts should:

- Use this to understand WAF presence and tailor payloads or bypass strategies.
- Document detected WAF vendors and signatures for future reference.

#### Testssl (`testssl.json`)

Structured TestSSL scan results including TLS configurations, supported cipher suites, and protocol details. Analysts should:

- Use this to identify weak ciphers, outdated SSL/TLS versions, or certificate misconfigurations.
- Review for compliance with current security best practices.

#### Sqlmap (`sqlmap.txt`)

Structured SQLMap scan output containing SQL injection findings and payloads. Analysts should:

- Use this to identify vulnerable parameters and confirm exploitation feasibility.
- Document injection types, DBMS details, and any data retrieved from the database.

#### Subzy (`subzy.txt`)

Structured Subzy scan output listing potential subdomain takeover vulnerabilities. Analysts should:

- Use this to identify abandoned DNS records pointing to third-party services.
- Validate and remediate by removing or claiming vulnerable subdomains.

#### Corsy (`corsy.txt`)

Structured Corsy scan results analyzing Cross-Origin Resource Sharing (CORS) configurations. Analysts should:

- Use this to detect misconfigured origins allowing unauthorized access.
- Review for wildcard (`*`) origins or reflection-based trust issues.

#### Nikto (`nikto.txt`)

Structured Nikto scan output identifying outdated software, misconfigurations, and known vulnerabilities. Analysts should:

- Use this to complement manual web application assessments.
- Review flagged issues for patching or hardening opportunities.

#### WPScan (`wpscan.json`)

Structured WPScan results including WordPress core, plugin, and theme vulnerabilities. Analysts should:

- Use this to track outdated components and known CVEs.
- Recommend upgrades or removal of vulnerable extensions.

#### RustScan (`rustscan.txt`)

Structured RustScan results enumerating open ports and responsive services. Analysts should:

- Use this to accelerate network reconnaissance with fast port discovery.
- Integrate with Nmap or other tools for detailed service enumeration.

#### Amass (`amass.txt`)

Structured Amass output listing discovered subdomains and DNS relationships. Analysts should:

- Use this for comprehensive subdomain enumeration and asset discovery.
- Correlate with other recon tools to build a full attack surface map.

#### DNSEnum (`dnsenum.xml`)

Structured DNSEnum results providing DNS record enumeration and zone transfer attempts. Analysts should:

- Use this to gather A, MX, NS, TXT, and CNAME records.
- Identify potential misconfigurations or information disclosure in DNS.

#### TheHarvester (`theharvester.json`)

Structured TheHarvester results aggregating OSINT data such as emails, subdomains, and hosts. Analysts should:

- Use this to collect reconnaissance data from public sources.
- Cross-check discovered assets and contacts with internal inventories.

#### Paramspider (`paramspider.txt`)

Structured ParamSpider output listing URLs and parameters for input-based vulnerabilities. Analysts should:

- Use this to feed into XSS, SSRF, and injection scanners.
- Review unique parameters for manual testing.

#### Ghauri (`ghauri.txt`)

Structured Ghauri results identifying SQL injection vulnerabilities using advanced techniques. Analysts should:

- Use this for in-depth SQLi detection and database fingerprinting.
- Review payloads and confirm exploitation paths.

#### cdncheck (`cdncheck.jsonl`)

Structured CDNCheck results identifying content delivery networks (CDNs) in use. Analysts should:

- Use this to detect CDN providers and confirm if assets are cached or protected.
- Review for exposed origin IPs that may bypass CDN protections.

#### ffuf (`ffuf.json`)

Structured FFUF results including discovered endpoints, parameters, and response codes. Analysts should:

- Use this to map hidden directories, files, and API endpoints.
- Review status codes and responses for unauthorized access or sensitive data exposure.

#### Dalfox (`Dalfox.jsonl`)

Structured Dalfox scan results including detected XSS payloads, reflection points, and scanning metadata. Analysts should:

- Use this to complement manual XSS testing with machine-readable JSONL data.
- Review findings for confirmed and potential XSS vectors.

#### SSLyze (`sslyze.json`)

Structured SSLyze scan results including details on SSL/TLS configurations, supported cipher suites, certificate information, and protocol security checks. Analysts should:

- Use this to assess SSL/TLS configurations and identify weak or deprecated protocols/ciphers.
- Review findings for misconfigurations, certificate issues, and compliance with security best practices (e.g., OWASP, NIST).

#### SMTP-User-Enum (`smtp-user-enum.txt`)

Structured SMTP enumeration results: probed addresses, server responses (VRFY/EXPN/RCPT), response codes, and target host/port.

- Use to find valid email accounts for user-mapping and phishing risk assessment.
- Correlate with logs and feed confirmed users into follow-up tests

#### Fierce (`fierce.txt`)
Structured DNS reconnaissance results: discovered subdomains, non-contiguous IP ranges, zone transfer attempts, and sweep metadata.

- Use to map DNS/IP footprint before active scanning.
- Flag successful AXFRs, wildcard DNS, and unexpected PTRs for remediation.

#### VirusTotal (`virustotal.json`)

Structured VirusTotal domain intelligence results: includes subdomains, associated IPs, file hash information, and scanned URLs for the queried domains.

- Use to identify subdomains and related IPs for mapping the domain’s external footprint.  
- Retrieve file hash values and metadata from uploaded or discovered files for malware verification and deeper analysis.  
- Review the list of URLs scanned for the target domain to support threat hunting and detection correlation.  

#### VulnAPI (`vulnapi.txt`)

Structured API security testing results: insecure endpoints, auth issues, missing headers, misconfigurations, and OpenAPI-based findings.

- Use to detect exposed or insecure API endpoints during assessments.  
- Identify missing security controls (auth, rate limits, CORS, headers).  
- Integrate into CI/CD to automatically scan APIs or OpenAPI specs before deployment.

#### Commix (`commix.txt`)

Structured command-injection testing results: detected injection points, vulnerable parameters, payloads used, and execution outputs.

- Use to identify command injection vulnerabilities in web parameters, headers, and forms.
- Validate exploitation impact by capturing executed command output or shell access.
- Quickly test multiple injection vectors during web app pentesting or bug bounty assessments.

#### WAF-Bypass (`waf-bypass.txt`)

Structured WAF evasion testing results: detected bypass techniques, payloads attempted, responses received, and any successful firewall evasions.

- Use to identify weaknesses or misconfigurations in Web Application Firewall (WAF) rules.  
- Validate whether harmful payloads can slip past filtering mechanisms.  
- Test multiple evasion vectors (obfuscation, encoding, transformation) during pentesting or security audits.  
- Determine how effectively the WAF blocks common attack classes such as SQLi, XSS, LFI/RFI, and command injection attempts.

#### Trivy (`trivy.txt`)

Structured vulnerability and misconfiguration scan results for source code, dependencies, and container images.

- Detect vulnerabilities and hardcoded secrets in source code and repositories.
- Identify CVEs in application dependencies, packages, and container images.
- Find security misconfigurations in IaC files such as Dockerfiles, Kubernetes manifests, and Terraform.

#### Vet (`vet.json`)

Structured software supply chain security scan results saved in JSON format for source code, dependencies, and container images.

- Detect malicious and potentially harmful open-source packages through active analysis.
- Identify known vulnerabilities in application dependencies with usage-aware risk prioritization.
- Enforce security controls using policy-as-code (CEL expressions) to flag or block risky dependencies.

---

This guide should be used alongside the summary step to quickly assess which artifacts need deeper analysis.
